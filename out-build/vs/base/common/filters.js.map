{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/filters.ts"],"names":[],"mappings":"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","file":"filters.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { LRUCache } from 'vs/base/common/map';\nimport * as strings from 'vs/base/common/strings';\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[] | null;\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] | null {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tconst match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n// Prefix\n\nexport const matchesStrictPrefix: IFilter = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix: IFilter = _matchesPrefix.bind(undefined, true);\n\nfunction _matchesPrefix(ignoreCase: boolean, word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\n\tlet matches: boolean;\n\tif (ignoreCase) {\n\t\tmatches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n\t} else {\n\t\tmatches = wordToMatchAgainst.indexOf(word) === 0;\n\t}\n\n\tif (!matches) {\n\t\treturn null;\n\t}\n\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\tconst index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] | null {\n\treturn _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word: string, wordToMatchAgainst: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] | null = null;\n\t\t\tif (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn CharCode.a <= code && code <= CharCode.z;\n}\n\nexport function isUpper(code: number): boolean {\n\treturn CharCode.A <= code && code <= CharCode.Z;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn CharCode.Digit0 <= code && code <= CharCode.Digit9;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn (\n\t\tcode === CharCode.Space\n\t\t|| code === CharCode.Tab\n\t\t|| code === CharCode.LineFeed\n\t\t|| code === CharCode.CarriageReturn\n\t);\n}\n\nconst wordSeparators = new Set<number>();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'\n\t.split('')\n\t.forEach(s => wordSeparators.add(s.charCodeAt(0)));\n\nfunction isWordSeparator(code: number): boolean {\n\treturn isWhitespace(code) || wordSeparators.has(code);\n}\n\nfunction charactersMatch(codeA: number, codeB: number): boolean {\n\treturn (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tconst c = camelCaseWord.charCodeAt(i);\n\t\tif (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word: string, camelCaseWord: string, i: number, j: number): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n\t\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\ninterface ICamelCaseAnalysis {\n\tupperPercent: number;\n\tlowerPercent: number;\n\talphaPercent: number;\n\tnumericPercent: number;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word: string): ICamelCaseAnalysis {\n\tlet upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isAlphanumeric(code)) { alpha++; }\n\t\tif (isNumber(code)) { numeric++; }\n\t}\n\n\tconst upperPercent = upper / word.length;\n\tconst lowerPercent = lower / word.length;\n\tconst alphaPercent = alpha / word.length;\n\tconst numericPercent = numeric / word.length;\n\n\treturn { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\n\nfunction isUpperCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent } = analysis;\n\treturn lowerPercent === 0 && upperPercent > 0.6;\n}\n\nfunction isCamelCaseWord(analysis: ICamelCaseAnalysis): boolean {\n\tconst { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n\treturn lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0, lower = 0, code = 0, whitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isWhitespace(code)) { whitespace++; }\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(word: string, camelCaseWord: string): IMatch[] | null {\n\tif (!camelCaseWord) {\n\t\treturn null;\n\t}\n\n\tcamelCaseWord = camelCaseWord.trim();\n\n\tif (camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\tif (camelCaseWord.length > 60) {\n\t\treturn null;\n\t}\n\n\tconst analysis = analyzeCamelCaseWord(camelCaseWord);\n\n\tif (!isCamelCaseWord(analysis)) {\n\t\tif (!isUpperCaseWord(analysis)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tcamelCaseWord = camelCaseWord.toLowerCase();\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\twhile (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word: string, target: string, contiguous: boolean = false): IMatch[] | null {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] | null = null;\n\tlet i = 0;\n\n\tword = word.toLowerCase();\n\ttarget = target.toLowerCase();\n\twhile (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n\t\ti = nextWord(target, i + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(word: string, target: string, i: number, j: number, contiguous: boolean): IMatch[] | null {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === target.length) {\n\t\treturn null;\n\t} else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n\t\treturn null;\n\t} else {\n\t\tlet result: IMatch[] | null = null;\n\t\tlet nextWordIndex = j + 1;\n\t\tresult = _matchesWords(word, target, i + 1, j + 1, contiguous);\n\t\tif (!contiguous) {\n\t\t\twhile (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n\t\t\t\tresult = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n\t\t\t\tnextWordIndex++;\n\t\t\t}\n\t\t}\n\n\t\tif (!result) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n\t\t// We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n\t\tif (word.charCodeAt(i) !== target.charCodeAt(j)) {\n\t\t\treturn result;\n\t\t}\n\n\t\treturn join({ start: j, end: j + 1 }, result);\n\t}\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tif (isWordSeparator(word.charCodeAt(i)) ||\n\t\t\t(i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache<string, RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word: string, wordToMatchAgainst: string, enableSeparateSubstringMatching = false): IMatch[] | null {\n\tif (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tconst match = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern: string, word: string): IMatch[] | null {\n\tconst score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\treturn score ? createMatches(score) : null;\n}\n\nexport function anyScore(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number): FuzzyScore {\n\tconst max = Math.min(13, pattern.length);\n\tfor (; patternPos < max; patternPos++) {\n\t\tconst result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn [0, wordPos];\n}\n\n//#region --- fuzzyScore ---\n\nexport function createMatches(score: undefined | FuzzyScore): IMatch[] {\n\tif (typeof score === 'undefined') {\n\t\treturn [];\n\t}\n\tconst res: IMatch[] = [];\n\tconst wordPos = score[1];\n\tfor (let i = score.length - 1; i > 1; i--) {\n\t\tconst pos = score[i] + wordPos;\n\t\tconst last = res[res.length - 1];\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end = pos + 1;\n\t\t} else {\n\t\t\tres.push({ start: pos, end: pos + 1 });\n\t\t}\n\t}\n\treturn res;\n}\n\nconst _maxLen = 128;\n\nfunction initTable() {\n\tconst table: number[][] = [];\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\tfor (let i = 0; i <= _maxLen; i++) {\n\t\ttable.push(row.slice(0));\n\t}\n\treturn table;\n}\n\nfunction initArr(maxLen: number) {\n\tconst row: number[] = [];\n\tfor (let i = 0; i <= maxLen; i++) {\n\t\trow[i] = 0;\n\t}\n\treturn row;\n}\n\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = <Arrow[][]>initTable();\nconst _debug = false;\n\nfunction printTable(table: number[][], pattern: string, patternLen: number, word: string, wordLen: number): string {\n\tfunction pad(s: string, n: number, pad = ' ') {\n\t\twhile (s.length < n) {\n\t\t\ts = pad + s;\n\t\t}\n\t\treturn s;\n\t}\n\tlet ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n\n\tfor (let i = 0; i <= patternLen; i++) {\n\t\tif (i === 0) {\n\t\t\tret += ' |';\n\t\t} else {\n\t\t\tret += `${pattern[i - 1]}|`;\n\t\t}\n\t\tret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n\t}\n\treturn ret;\n}\n\nfunction printTables(pattern: string, patternStart: number, word: string, wordStart: number): void {\n\tpattern = pattern.substr(patternStart);\n\tword = word.substr(wordStart);\n\tconsole.log(printTable(_table, pattern, pattern.length, word, word.length));\n\tconsole.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n\tconsole.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\n\nfunction isSeparatorAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.codePointAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\tcase CharCode.DollarSign:\n\t\tcase CharCode.LessThan:\n\t\tcase CharCode.GreaterThan:\n\t\tcase CharCode.OpenParen:\n\t\tcase CharCode.CloseParen:\n\t\tcase CharCode.OpenSquareBracket:\n\t\tcase CharCode.CloseSquareBracket:\n\t\tcase CharCode.OpenCurlyBrace:\n\t\tcase CharCode.CloseCurlyBrace:\n\t\t\treturn true;\n\t\tcase undefined:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tif (strings.isEmojiImprecise(code)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t}\n}\n\nfunction isWhitespaceAtPos(value: string, index: number): boolean {\n\tif (index < 0 || index >= value.length) {\n\t\treturn false;\n\t}\n\tconst code = value.charCodeAt(index);\n\tswitch (code) {\n\t\tcase CharCode.Space:\n\t\tcase CharCode.Tab:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nfunction isUpperCaseAtPos(pos: number, word: string, wordLow: string): boolean {\n\treturn word[pos] !== wordLow[pos];\n}\n\nexport function isPatternInWord(patternLow: string, patternPos: number, patternLen: number, wordLow: string, wordPos: number, wordLen: number, fillMinWordPosArr = false): boolean {\n\twhile (patternPos < patternLen && wordPos < wordLen) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\tif (fillMinWordPosArr) {\n\t\t\t\t// Remember the min word position for each pattern position\n\t\t\t\t_minWordMatchPos[patternPos] = wordPos;\n\t\t\t}\n\t\t\tpatternPos += 1;\n\t\t}\n\t\twordPos += 1;\n\t}\n\treturn patternPos === patternLen; // pattern must be exhausted\n}\n\nconst enum Arrow { Diag = 1, Left = 2, LeftLeft = 3 }\n\n/**\n * An array representing a fuzzy match.\n *\n * 0. the score\n * 1. the offset at which matching started\n * 2. `<match_pos_N>`\n * 3. `<match_pos_1>`\n * 4. `<match_pos_0>` etc\n */\nexport type FuzzyScore = [score: number, wordStart: number, ...matches: number[]];\n\nexport namespace FuzzyScore {\n\t/**\n\t * No matches and value `-100`\n\t */\n\texport const Default: FuzzyScore = ([-100, 0]);\n\n\texport function isDefault(score?: FuzzyScore): score is [-100, 0] {\n\t\treturn !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n\t}\n}\n\nexport abstract class FuzzyScoreOptions {\n\n\tstatic default = { boostFullMatch: true, firstMatchCanBeWeak: false };\n\n\tconstructor(\n\t\treadonly firstMatchCanBeWeak: boolean,\n\t\treadonly boostFullMatch: boolean,\n\t) { }\n}\n\nexport interface FuzzyScorer {\n\t(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined;\n}\n\nexport function fuzzyScore(pattern: string, patternLow: string, patternStart: number, word: string, wordLow: string, wordStart: number, options: FuzzyScoreOptions = FuzzyScoreOptions.default): FuzzyScore | undefined {\n\n\tconst patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n\tconst wordLen = word.length > _maxLen ? _maxLen : word.length;\n\n\tif (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n\t\treturn undefined;\n\t}\n\n\t// Run a simple check if the characters of pattern occur\n\t// (in order) at all in word. If that isn't the case we\n\t// stop because no match will be possible\n\tif (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n\t\treturn undefined;\n\t}\n\n\t// Find the max matching word position for each pattern position\n\t// NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n\t_fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n\n\tlet row: number = 1;\n\tlet column: number = 1;\n\tlet patternPos = patternStart;\n\tlet wordPos = wordStart;\n\n\tconst hasStrongFirstMatch = [false];\n\n\t// There will be a match, fill in tables\n\tfor (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n\n\t\t// Reduce search space to possible matching word positions and to possible access from next row\n\t\tconst minWordMatchPos = _minWordMatchPos[patternPos];\n\t\tconst maxWordMatchPos = _maxWordMatchPos[patternPos];\n\t\tconst nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n\n\t\tfor (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n\n\t\t\tlet score = Number.MIN_SAFE_INTEGER;\n\t\t\tlet canComeDiag = false;\n\n\t\t\tif (wordPos <= maxWordMatchPos) {\n\t\t\t\tscore = _doScore(\n\t\t\t\t\tpattern, patternLow, patternPos, patternStart,\n\t\t\t\t\tword, wordLow, wordPos, wordLen, wordStart,\n\t\t\t\t\t_diag[row - 1][column - 1] === 0,\n\t\t\t\t\thasStrongFirstMatch\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet diagScore = 0;\n\t\t\tif (score !== Number.MAX_SAFE_INTEGER) {\n\t\t\t\tcanComeDiag = true;\n\t\t\t\tdiagScore = score + _table[row - 1][column - 1];\n\t\t\t}\n\n\t\t\tconst canComeLeft = wordPos > minWordMatchPos;\n\t\t\tconst leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n\t\t\tconst canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n\t\t\tconst leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n\n\t\t\tif (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n\t\t\t\t// always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftLeftScore;\n\t\t\t\t_arrows[row][column] = Arrow.LeftLeft;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n\t\t\t\t// always prefer choosing left since that means a match is earlier in the word\n\t\t\t\t_table[row][column] = leftScore;\n\t\t\t\t_arrows[row][column] = Arrow.Left;\n\t\t\t\t_diag[row][column] = 0;\n\t\t\t} else if (canComeDiag) {\n\t\t\t\t_table[row][column] = diagScore;\n\t\t\t\t_arrows[row][column] = Arrow.Diag;\n\t\t\t\t_diag[row][column] = _diag[row - 1][column - 1] + 1;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`not possible`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_debug) {\n\t\tprintTables(pattern, patternStart, word, wordStart);\n\t}\n\n\tif (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n\t\treturn undefined;\n\t}\n\n\trow--;\n\tcolumn--;\n\n\tconst result: FuzzyScore = [_table[row][column], wordStart];\n\n\tlet backwardsDiagLength = 0;\n\tlet maxMatchColumn = 0;\n\n\twhile (row >= 1) {\n\t\t// Find the column where we go diagonally up\n\t\tlet diagColumn = column;\n\t\tdo {\n\t\t\tconst arrow = _arrows[row][diagColumn];\n\t\t\tif (arrow === Arrow.LeftLeft) {\n\t\t\t\tdiagColumn = diagColumn - 2;\n\t\t\t} else if (arrow === Arrow.Left) {\n\t\t\t\tdiagColumn = diagColumn - 1;\n\t\t\t} else {\n\t\t\t\t// found the diagonal\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (diagColumn >= 1);\n\n\t\t// Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n\t\tif (\n\t\t\tbackwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n\t\t\t&& patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n\t\t\t&& !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n\t\t\t&& backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n\t\t) {\n\t\t\tdiagColumn = column;\n\t\t}\n\n\t\tif (diagColumn === column) {\n\t\t\t// this is a contiguous match\n\t\t\tbackwardsDiagLength++;\n\t\t} else {\n\t\t\tbackwardsDiagLength = 1;\n\t\t}\n\n\t\tif (!maxMatchColumn) {\n\t\t\t// remember the last matched column\n\t\t\tmaxMatchColumn = diagColumn;\n\t\t}\n\n\t\trow--;\n\t\tcolumn = diagColumn - 1;\n\t\tresult.push(column);\n\t}\n\n\tif (wordLen === patternLen && options.boostFullMatch) {\n\t\t// the word matches the pattern with all characters!\n\t\t// giving the score a total match boost (to come up ahead other words)\n\t\tresult[0] += 2;\n\t}\n\n\t// Add 1 penalty for each skipped character in the word\n\tconst skippedCharsCount = maxMatchColumn - patternLen;\n\tresult[0] -= skippedCharsCount;\n\n\treturn result;\n}\n\nfunction _fillInMaxWordMatchPos(patternLen: number, wordLen: number, patternStart: number, wordStart: number, patternLow: string, wordLow: string) {\n\tlet patternPos = patternLen - 1;\n\tlet wordPos = wordLen - 1;\n\twhile (patternPos >= patternStart && wordPos >= wordStart) {\n\t\tif (patternLow[patternPos] === wordLow[wordPos]) {\n\t\t\t_maxWordMatchPos[patternPos] = wordPos;\n\t\t\tpatternPos--;\n\t\t}\n\t\twordPos--;\n\t}\n}\n\nfunction _doScore(\n\tpattern: string, patternLow: string, patternPos: number, patternStart: number,\n\tword: string, wordLow: string, wordPos: number, wordLen: number, wordStart: number,\n\tnewMatchStart: boolean,\n\toutFirstMatchStrong: boolean[],\n): number {\n\tif (patternLow[patternPos] !== wordLow[wordPos]) {\n\t\treturn Number.MIN_SAFE_INTEGER;\n\t}\n\n\tlet score = 1;\n\tlet isGapLocation = false;\n\tif (wordPos === (patternPos - patternStart)) {\n\t\t// common prefix: `foobar <-> foobaz`\n\t\t//                            ^^^^^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\n\t} else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n\t\t// hitting upper-case: `foo <-> forOthers`\n\t\t//                              ^^ ^\n\t\tscore = pattern[patternPos] === word[wordPos] ? 7 : 5;\n\t\tisGapLocation = true;\n\n\t} else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n\t\t// hitting a separator: `. <-> foo.bar`\n\t\t//                                ^\n\t\tscore = 5;\n\n\t} else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n\t\t// post separator: `foo <-> bar_foo`\n\t\t//                              ^^^\n\t\tscore = 5;\n\t\tisGapLocation = true;\n\t}\n\n\tif (score > 1 && patternPos === patternStart) {\n\t\toutFirstMatchStrong[0] = true;\n\t}\n\n\tif (!isGapLocation) {\n\t\tisGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n\t}\n\n\t//\n\tif (patternPos === patternStart) { // first character in pattern\n\t\tif (wordPos > wordStart) {\n\t\t\t// the first pattern character would match a word character that is not at the word start\n\t\t\t// so introduce a penalty to account for the gap preceding this match\n\t\t\tscore -= isGapLocation ? 3 : 5;\n\t\t}\n\t} else {\n\t\tif (newMatchStart) {\n\t\t\t// this would be the beginning of a new match (i.e. there would be a gap before this location)\n\t\t\tscore += isGapLocation ? 2 : 0;\n\t\t} else {\n\t\t\t// this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n\t\t\tscore += isGapLocation ? 0 : 1;\n\t\t}\n\t}\n\n\tif (wordPos + 1 === wordLen) {\n\t\t// we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n\t\t// so pretend there is a gap after the last character in the word to normalize things\n\t\tscore -= isGapLocation ? 3 : 5;\n\t}\n\n\treturn score;\n}\n\n//#endregion\n\n\n//#region --- graceful ---\n\nexport function fuzzyScoreGracefulAggressive(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\n\nexport function fuzzyScoreGraceful(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\treturn fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, false, options);\n}\n\nfunction fuzzyScoreWithPermutations(pattern: string, lowPattern: string, patternPos: number, word: string, lowWord: string, wordPos: number, aggressive: boolean, options?: FuzzyScoreOptions): FuzzyScore | undefined {\n\tlet top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n\n\tif (top && !aggressive) {\n\t\t// when using the original pattern yield a result we`\n\t\t// return it unless we are aggressive and try to find\n\t\t// a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n\t\treturn top;\n\t}\n\n\tif (pattern.length >= 3) {\n\t\t// When the pattern is long enough then try a few (max 7)\n\t\t// permutations of the pattern to find a better match. The\n\t\t// permutations only swap neighbouring characters, e.g\n\t\t// `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n\t\tconst tries = Math.min(7, pattern.length - 1);\n\t\tfor (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n\t\t\tconst newPattern = nextTypoPermutation(pattern, movingPatternPos);\n\t\t\tif (newPattern) {\n\t\t\t\tconst candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n\t\t\t\tif (candidate) {\n\t\t\t\t\tcandidate[0] -= 3; // permutation penalty\n\t\t\t\t\tif (!top || candidate[0] > top[0]) {\n\t\t\t\t\t\ttop = candidate;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn top;\n}\n\nfunction nextTypoPermutation(pattern: string, patternPos: number): string | undefined {\n\n\tif (patternPos + 1 >= pattern.length) {\n\t\treturn undefined;\n\t}\n\n\tconst swap1 = pattern[patternPos];\n\tconst swap2 = pattern[patternPos + 1];\n\n\tif (swap1 === swap2) {\n\t\treturn undefined;\n\t}\n\n\treturn pattern.slice(0, patternPos)\n\t\t+ swap2\n\t\t+ swap1\n\t\t+ pattern.slice(patternPos + 2);\n}\n\n//#endregion\n"]}