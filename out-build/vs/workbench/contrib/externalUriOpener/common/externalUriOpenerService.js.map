{"version":3,"sources":["vs/workbench/contrib/externalUriOpener/common/externalUriOpenerService.ts"],"names":[],"mappings":"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","file":"externalUriOpenerService.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { firstOrDefault } from 'vs/base/common/arrays';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { Iterable } from 'vs/base/common/iterator';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { LinkedList } from 'vs/base/common/linkedList';\nimport { isWeb } from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\nimport * as languages from 'vs/editor/common/languages';\nimport * as nls from 'vs/nls';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { createDecorator } from 'vs/platform/instantiation/common/instantiation';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IExternalOpener, IOpenerService } from 'vs/platform/opener/common/opener';\nimport { IQuickInputService, IQuickPickItem, IQuickPickSeparator } from 'vs/platform/quickinput/common/quickInput';\nimport { defaultExternalUriOpenerId, ExternalUriOpenersConfiguration, externalUriOpenersSettingId } from 'vs/workbench/contrib/externalUriOpener/common/configuration';\nimport { testUrlMatchesGlob } from 'vs/workbench/contrib/url/common/urlGlob';\nimport { IPreferencesService } from 'vs/workbench/services/preferences/common/preferences';\n\n\nexport const IExternalUriOpenerService = createDecorator<IExternalUriOpenerService>('externalUriOpenerService');\n\n\nexport interface IExternalOpenerProvider {\n\tgetOpeners(targetUri: URI): AsyncIterable<IExternalUriOpener>;\n}\n\nexport interface IExternalUriOpener {\n\treadonly id: string;\n\treadonly label: string;\n\n\tcanOpen(uri: URI, token: CancellationToken): Promise<languages.ExternalUriOpenerPriority>;\n\topenExternalUri(uri: URI, ctx: { sourceUri: URI }, token: CancellationToken): Promise<boolean>;\n}\n\nexport interface IExternalUriOpenerService {\n\treadonly _serviceBrand: undefined;\n\n\t/**\n\t * Registers a provider for external resources openers.\n\t */\n\tregisterExternalOpenerProvider(provider: IExternalOpenerProvider): IDisposable;\n\n\t/**\n\t * Get the configured IExternalUriOpener for the the uri.\n\t * If there is no opener configured, then returns the first opener that can handle the uri.\n\t */\n\tgetOpener(uri: URI, ctx: { sourceUri: URI; preferredOpenerId?: string }, token: CancellationToken): Promise<IExternalUriOpener | undefined>;\n}\n\nexport class ExternalUriOpenerService extends Disposable implements IExternalUriOpenerService, IExternalOpener {\n\n\tpublic readonly _serviceBrand: undefined;\n\n\tprivate readonly _providers = new LinkedList<IExternalOpenerProvider>();\n\n\tconstructor(\n\t\t@IOpenerService openerService: IOpenerService,\n\t\t@IConfigurationService private readonly configurationService: IConfigurationService,\n\t\t@ILogService private readonly logService: ILogService,\n\t\t@IPreferencesService private readonly preferencesService: IPreferencesService,\n\t\t@IQuickInputService private readonly quickInputService: IQuickInputService,\n\t) {\n\t\tsuper();\n\t\tthis._register(openerService.registerExternalOpener(this));\n\t}\n\n\tregisterExternalOpenerProvider(provider: IExternalOpenerProvider): IDisposable {\n\t\tconst remove = this._providers.push(provider);\n\t\treturn { dispose: remove };\n\t}\n\n\tprivate async getOpeners(targetUri: URI, allowOptional: boolean, ctx: { sourceUri: URI; preferredOpenerId?: string }, token: CancellationToken): Promise<IExternalUriOpener[]> {\n\t\tconst allOpeners = await this.getAllOpenersForUri(targetUri);\n\n\t\tif (allOpeners.size === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// First see if we have a preferredOpener\n\t\tif (ctx.preferredOpenerId) {\n\t\t\tif (ctx.preferredOpenerId === defaultExternalUriOpenerId) {\n\t\t\t\treturn [];\n\t\t\t}\n\n\t\t\tconst preferredOpener = allOpeners.get(ctx.preferredOpenerId);\n\t\t\tif (preferredOpener) {\n\t\t\t\t// Skip the `canOpen` check here since the opener was specifically requested.\n\t\t\t\treturn [preferredOpener];\n\t\t\t}\n\t\t}\n\n\t\t// Check to see if we have a configured opener\n\t\tconst configuredOpener = this.getConfiguredOpenerForUri(allOpeners, targetUri);\n\t\tif (configuredOpener) {\n\t\t\t// Skip the `canOpen` check here since the opener was specifically requested.\n\t\t\treturn configuredOpener === defaultExternalUriOpenerId ? [] : [configuredOpener];\n\t\t}\n\n\t\t// Then check to see if there is a valid opener\n\t\tconst validOpeners: Array<{ opener: IExternalUriOpener; priority: languages.ExternalUriOpenerPriority }> = [];\n\t\tawait Promise.all(Array.from(allOpeners.values()).map(async opener => {\n\t\t\tlet priority: languages.ExternalUriOpenerPriority;\n\t\t\ttry {\n\t\t\t\tpriority = await opener.canOpen(ctx.sourceUri, token);\n\t\t\t} catch (e) {\n\t\t\t\tthis.logService.error(e);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch (priority) {\n\t\t\t\tcase languages.ExternalUriOpenerPriority.Option:\n\t\t\t\tcase languages.ExternalUriOpenerPriority.Default:\n\t\t\t\tcase languages.ExternalUriOpenerPriority.Preferred:\n\t\t\t\t\tvalidOpeners.push({ opener, priority });\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}));\n\n\t\tif (validOpeners.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// See if we have a preferred opener first\n\t\tconst preferred = firstOrDefault(validOpeners.filter(x => x.priority === languages.ExternalUriOpenerPriority.Preferred));\n\t\tif (preferred) {\n\t\t\treturn [preferred.opener];\n\t\t}\n\n\t\t// See if we only have optional openers, use the default opener\n\t\tif (!allowOptional && validOpeners.every(x => x.priority === languages.ExternalUriOpenerPriority.Option)) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn validOpeners.map(value => value.opener);\n\t}\n\n\tasync openExternal(href: string, ctx: { sourceUri: URI; preferredOpenerId?: string }, token: CancellationToken): Promise<boolean> {\n\n\t\tconst targetUri = typeof href === 'string' ? URI.parse(href) : href;\n\n\t\tconst allOpeners = await this.getOpeners(targetUri, false, ctx, token);\n\t\tif (allOpeners.length === 0) {\n\t\t\treturn false;\n\t\t} else if (allOpeners.length === 1) {\n\t\t\treturn allOpeners[0].openExternalUri(targetUri, ctx, token);\n\t\t}\n\n\t\t// Otherwise prompt\n\t\treturn this.showOpenerPrompt(allOpeners, targetUri, ctx, token);\n\t}\n\n\tasync getOpener(targetUri: URI, ctx: { sourceUri: URI; preferredOpenerId?: string }, token: CancellationToken): Promise<IExternalUriOpener | undefined> {\n\t\tconst allOpeners = await this.getOpeners(targetUri, true, ctx, token);\n\t\tif (allOpeners.length >= 1) {\n\t\t\treturn allOpeners[0];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate async getAllOpenersForUri(targetUri: URI): Promise<Map<string, IExternalUriOpener>> {\n\t\tconst allOpeners = new Map<string, IExternalUriOpener>();\n\t\tawait Promise.all(Iterable.map(this._providers, async (provider) => {\n\t\t\tfor await (const opener of provider.getOpeners(targetUri)) {\n\t\t\t\tallOpeners.set(opener.id, opener);\n\t\t\t}\n\t\t}));\n\t\treturn allOpeners;\n\t}\n\n\tprivate getConfiguredOpenerForUri(openers: Map<string, IExternalUriOpener>, targetUri: URI): IExternalUriOpener | 'default' | undefined {\n\t\tconst config = this.configurationService.getValue<ExternalUriOpenersConfiguration>(externalUriOpenersSettingId) || {};\n\t\tfor (const [uriGlob, id] of Object.entries(config)) {\n\t\t\tif (testUrlMatchesGlob(targetUri, uriGlob)) {\n\t\t\t\tif (id === defaultExternalUriOpenerId) {\n\t\t\t\t\treturn 'default';\n\t\t\t\t}\n\n\t\t\t\tconst entry = openers.get(id);\n\t\t\t\tif (entry) {\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tprivate async showOpenerPrompt(\n\t\topeners: ReadonlyArray<IExternalUriOpener>,\n\t\ttargetUri: URI,\n\t\tctx: { sourceUri: URI },\n\t\ttoken: CancellationToken\n\t): Promise<boolean> {\n\t\ttype PickItem = IQuickPickItem & { opener?: IExternalUriOpener | 'configureDefault' };\n\n\t\tconst items: Array<PickItem | IQuickPickSeparator> = openers.map((opener): PickItem => {\n\t\t\treturn {\n\t\t\t\tlabel: opener.label,\n\t\t\t\topener: opener\n\t\t\t};\n\t\t});\n\t\titems.push(\n\t\t\t{\n\t\t\t\tlabel: isWeb\n\t\t\t\t\t? nls.localize('selectOpenerDefaultLabel.web', 'Open in new browser window')\n\t\t\t\t\t: nls.localize('selectOpenerDefaultLabel', 'Open in default browser'),\n\t\t\t\topener: undefined\n\t\t\t},\n\t\t\t{ type: 'separator' },\n\t\t\t{\n\t\t\t\tlabel: nls.localize('selectOpenerConfigureTitle', \"Configure default opener...\"),\n\t\t\t\topener: 'configureDefault'\n\t\t\t});\n\n\t\tconst picked = await this.quickInputService.pick(items, {\n\t\t\tplaceHolder: nls.localize('selectOpenerPlaceHolder', \"How would you like to open: {0}\", targetUri.toString())\n\t\t});\n\n\t\tif (!picked) {\n\t\t\t// Still cancel the default opener here since we prompted the user\n\t\t\treturn true;\n\t\t}\n\n\t\tif (typeof picked.opener === 'undefined') {\n\t\t\treturn false; // Fallback to default opener\n\t\t} else if (picked.opener === 'configureDefault') {\n\t\t\tawait this.preferencesService.openUserSettings({\n\t\t\t\tjsonEditor: true,\n\t\t\t\trevealSetting: { key: externalUriOpenersSettingId, edit: true }\n\t\t\t});\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn picked.opener.openExternalUri(targetUri, ctx, token);\n\t\t}\n\t}\n}\n"]}