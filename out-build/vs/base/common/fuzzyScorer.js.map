{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/fuzzyScorer.ts"],"names":[],"mappings":"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","file":"fuzzyScorer.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { compareAnything } from 'vs/base/common/comparers';\nimport { createMatches as createFuzzyMatches, fuzzyScore, IMatch, isUpper, matchesPrefix } from 'vs/base/common/filters';\nimport { hash } from 'vs/base/common/hash';\nimport { sep } from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, stripWildcards } from 'vs/base/common/strings';\n\n//#region Fuzzy scorer\n\nexport type FuzzyScore = [number /* score */, number[] /* match positions */];\nexport type FuzzyScorerCache = { [key: string]: IItemScore };\n\nconst NO_MATCH = 0;\nconst NO_SCORE: FuzzyScore = [NO_MATCH, []];\n\n// const DEBUG = true;\n// const DEBUG_MATRIX = false;\n\nexport function scoreFuzzy(target: string, query: string, queryLower: string, allowNonContiguousMatches: boolean): FuzzyScore {\n\tif (!target || !query) {\n\t\treturn NO_SCORE; // return early if target or query are undefined\n\t}\n\n\tconst targetLength = target.length;\n\tconst queryLength = query.length;\n\n\tif (targetLength < queryLength) {\n\t\treturn NO_SCORE; // impossible for query to be contained in target\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.group(`Target: ${target}, Query: ${query}`);\n\t// }\n\n\tconst targetLower = target.toLowerCase();\n\tconst res = doScoreFuzzy(query, queryLower, queryLength, target, targetLower, targetLength, allowNonContiguousMatches);\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cFinal Score: ${res[0]}`, 'font-weight: bold');\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn res;\n}\n\nfunction doScoreFuzzy(query: string, queryLower: string, queryLength: number, target: string, targetLower: string, targetLength: number, allowNonContiguousMatches: boolean): FuzzyScore {\n\tconst scores: number[] = [];\n\tconst matches: number[] = [];\n\n\t//\n\t// Build Scorer Matrix:\n\t//\n\t// The matrix is composed of query q and target t. For each index we score\n\t// q[i] with t[i] and compare that with the previous score. If the score is\n\t// equal or larger, we keep the match. In addition to the score, we also keep\n\t// the length of the consecutive matches to use as boost for the score.\n\t//\n\t//      t   a   r   g   e   t\n\t//  q\n\t//  u\n\t//  e\n\t//  r\n\t//  y\n\t//\n\tfor (let queryIndex = 0; queryIndex < queryLength; queryIndex++) {\n\t\tconst queryIndexOffset = queryIndex * targetLength;\n\t\tconst queryIndexPreviousOffset = queryIndexOffset - targetLength;\n\n\t\tconst queryIndexGtNull = queryIndex > 0;\n\n\t\tconst queryCharAtIndex = query[queryIndex];\n\t\tconst queryLowerCharAtIndex = queryLower[queryIndex];\n\n\t\tfor (let targetIndex = 0; targetIndex < targetLength; targetIndex++) {\n\t\t\tconst targetIndexGtNull = targetIndex > 0;\n\n\t\t\tconst currentIndex = queryIndexOffset + targetIndex;\n\t\t\tconst leftIndex = currentIndex - 1;\n\t\t\tconst diagIndex = queryIndexPreviousOffset + targetIndex - 1;\n\n\t\t\tconst leftScore = targetIndexGtNull ? scores[leftIndex] : 0;\n\t\t\tconst diagScore = queryIndexGtNull && targetIndexGtNull ? scores[diagIndex] : 0;\n\n\t\t\tconst matchesSequenceLength = queryIndexGtNull && targetIndexGtNull ? matches[diagIndex] : 0;\n\n\t\t\t// If we are not matching on the first query character any more, we only produce a\n\t\t\t// score if we had a score previously for the last query index (by looking at the diagScore).\n\t\t\t// This makes sure that the query always matches in sequence on the target. For example\n\t\t\t// given a target of \"ede\" and a query of \"de\", we would otherwise produce a wrong high score\n\t\t\t// for query[1] (\"e\") matching on target[0] (\"e\") because of the \"beginning of word\" boost.\n\t\t\tlet score: number;\n\t\t\tif (!diagScore && queryIndexGtNull) {\n\t\t\t\tscore = 0;\n\t\t\t} else {\n\t\t\t\tscore = computeCharScore(queryCharAtIndex, queryLowerCharAtIndex, target, targetLower, targetIndex, matchesSequenceLength);\n\t\t\t}\n\n\t\t\t// We have a score and its equal or larger than the left score\n\t\t\t// Match: sequence continues growing from previous diag value\n\t\t\t// Score: increases by diag score value\n\t\t\tconst isValidScore = score && diagScore + score >= leftScore;\n\t\t\tif (isValidScore && (\n\t\t\t\t// We don't need to check if it's contiguous if we allow non-contiguous matches\n\t\t\t\tallowNonContiguousMatches ||\n\t\t\t\t// We must be looking for a contiguous match.\n\t\t\t\t// Looking at an index higher than 0 in the query means we must have already\n\t\t\t\t// found out this is contiguous otherwise there wouldn't have been a score\n\t\t\t\tqueryIndexGtNull ||\n\t\t\t\t// lastly check if the query is completely contiguous at this index in the target\n\t\t\t\ttargetLower.startsWith(queryLower, targetIndex)\n\t\t\t)) {\n\t\t\t\tmatches[currentIndex] = matchesSequenceLength + 1;\n\t\t\t\tscores[currentIndex] = diagScore + score;\n\t\t\t}\n\n\t\t\t// We either have no score or the score is lower than the left score\n\t\t\t// Match: reset to 0\n\t\t\t// Score: pick up from left hand side\n\t\t\telse {\n\t\t\t\tmatches[currentIndex] = NO_MATCH;\n\t\t\t\tscores[currentIndex] = leftScore;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Restore Positions (starting from bottom right of matrix)\n\tconst positions: number[] = [];\n\tlet queryIndex = queryLength - 1;\n\tlet targetIndex = targetLength - 1;\n\twhile (queryIndex >= 0 && targetIndex >= 0) {\n\t\tconst currentIndex = queryIndex * targetLength + targetIndex;\n\t\tconst match = matches[currentIndex];\n\t\tif (match === NO_MATCH) {\n\t\t\ttargetIndex--; // go left\n\t\t} else {\n\t\t\tpositions.push(targetIndex);\n\n\t\t\t// go up and left\n\t\t\tqueryIndex--;\n\t\t\ttargetIndex--;\n\t\t}\n\t}\n\n\t// Print matrix\n\t// if (DEBUG_MATRIX) {\n\t// \tprintMatrix(query, target, matches, scores);\n\t// }\n\n\treturn [scores[queryLength * targetLength - 1], positions.reverse()];\n}\n\nfunction computeCharScore(queryCharAtIndex: string, queryLowerCharAtIndex: string, target: string, targetLower: string, targetIndex: number, matchesSequenceLength: number): number {\n\tlet score = 0;\n\n\tif (!considerAsEqual(queryLowerCharAtIndex, targetLower[targetIndex])) {\n\t\treturn score; // no match of characters\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.groupCollapsed(`%cFound a match of char: ${queryLowerCharAtIndex} at index ${targetIndex}`, 'font-weight: normal');\n\t// }\n\n\t// Character match bonus\n\tscore += 1;\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`%cCharacter match bonus: +1`, 'font-weight: normal');\n\t// }\n\n\t// Consecutive match bonus\n\tif (matchesSequenceLength > 0) {\n\t\tscore += (matchesSequenceLength * 5);\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log(`Consecutive match bonus: +${matchesSequenceLength * 5}`);\n\t\t// }\n\t}\n\n\t// Same case bonus\n\tif (queryCharAtIndex === target[targetIndex]) {\n\t\tscore += 1;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Same case bonus: +1');\n\t\t// }\n\t}\n\n\t// Start of word bonus\n\tif (targetIndex === 0) {\n\t\tscore += 8;\n\n\t\t// if (DEBUG) {\n\t\t// \tconsole.log('Start of word bonus: +8');\n\t\t// }\n\t}\n\n\telse {\n\n\t\t// After separator bonus\n\t\tconst separatorBonus = scoreSeparatorAtPos(target.charCodeAt(targetIndex - 1));\n\t\tif (separatorBonus) {\n\t\t\tscore += separatorBonus;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log(`After separator bonus: +${separatorBonus}`);\n\t\t\t// }\n\t\t}\n\n\t\t// Inside word upper case bonus (camel case). We only give this bonus if we're not in a contiguous sequence.\n\t\t// For example:\n\t\t// NPE => NullPointerException = boost\n\t\t// HTTP => HTTP = not boost\n\t\telse if (isUpper(target.charCodeAt(targetIndex)) && matchesSequenceLength === 0) {\n\t\t\tscore += 2;\n\n\t\t\t// if (DEBUG) {\n\t\t\t// \tconsole.log('Inside word upper case bonus: +2');\n\t\t\t// }\n\t\t}\n\t}\n\n\t// if (DEBUG) {\n\t// \tconsole.log(`Total score: ${score}`);\n\t// \tconsole.groupEnd();\n\t// }\n\n\treturn score;\n}\n\nfunction considerAsEqual(a: string, b: string): boolean {\n\tif (a === b) {\n\t\treturn true;\n\t}\n\n\t// Special case path separators: ignore platform differences\n\tif (a === '/' || a === '\\\\') {\n\t\treturn b === '/' || b === '\\\\';\n\t}\n\n\treturn false;\n}\n\nfunction scoreSeparatorAtPos(charCode: number): number {\n\tswitch (charCode) {\n\t\tcase CharCode.Slash:\n\t\tcase CharCode.Backslash:\n\t\t\treturn 5; // prefer path separators...\n\t\tcase CharCode.Underline:\n\t\tcase CharCode.Dash:\n\t\tcase CharCode.Period:\n\t\tcase CharCode.Space:\n\t\tcase CharCode.SingleQuote:\n\t\tcase CharCode.DoubleQuote:\n\t\tcase CharCode.Colon:\n\t\t\treturn 4; // ...over other separators\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n// function printMatrix(query: string, target: string, matches: number[], scores: number[]): void {\n// \tconsole.log('\\t' + target.split('').join('\\t'));\n// \tfor (let queryIndex = 0; queryIndex < query.length; queryIndex++) {\n// \t\tlet line = query[queryIndex] + '\\t';\n// \t\tfor (let targetIndex = 0; targetIndex < target.length; targetIndex++) {\n// \t\t\tconst currentIndex = queryIndex * target.length + targetIndex;\n// \t\t\tline = line + 'M' + matches[currentIndex] + '/' + 'S' + scores[currentIndex] + '\\t';\n// \t\t}\n\n// \t\tconsole.log(line);\n// \t}\n// }\n\n//#endregion\n\n\n//#region Alternate fuzzy scorer implementation that is e.g. used for symbols\n\nexport type FuzzyScore2 = [number | undefined /* score */, IMatch[]];\n\nconst NO_SCORE2: FuzzyScore2 = [undefined, []];\n\nexport function scoreFuzzy2(target: string, query: IPreparedQuery | IPreparedQueryPiece, patternStart = 0, wordStart = 0): FuzzyScore2 {\n\n\t// Score: multiple inputs\n\tconst preparedQuery = query as IPreparedQuery;\n\tif (preparedQuery.values && preparedQuery.values.length > 1) {\n\t\treturn doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);\n\t}\n\n\t// Score: single input\n\treturn doScoreFuzzy2Single(target, query, patternStart, wordStart);\n}\n\nfunction doScoreFuzzy2Multiple(target: string, query: IPreparedQueryPiece[], patternStart: number, wordStart: number): FuzzyScore2 {\n\tlet totalScore = 0;\n\tconst totalMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);\n\t\tif (typeof score !== 'number') {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_SCORE2;\n\t\t}\n\n\t\ttotalScore += score;\n\t\ttotalMatches.push(...matches);\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn [totalScore, normalizeMatches(totalMatches)];\n}\n\nfunction doScoreFuzzy2Single(target: string, query: IPreparedQueryPiece, patternStart: number, wordStart: number): FuzzyScore2 {\n\tconst score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, { firstMatchCanBeWeak: true, boostFullMatch: true });\n\tif (!score) {\n\t\treturn NO_SCORE2;\n\t}\n\n\treturn [score[0], createFuzzyMatches(score)];\n}\n\n//#endregion\n\n\n//#region Item (label, description, path) scorer\n\n/**\n * Scoring on structural items that have a label and optional description.\n */\nexport interface IItemScore {\n\n\t/**\n\t * Overall score.\n\t */\n\tscore: number;\n\n\t/**\n\t * Matches within the label.\n\t */\n\tlabelMatch?: IMatch[];\n\n\t/**\n\t * Matches within the description.\n\t */\n\tdescriptionMatch?: IMatch[];\n}\n\nconst NO_ITEM_SCORE = Object.freeze<IItemScore>({ score: 0 });\n\nexport interface IItemAccessor<T> {\n\n\t/**\n\t * Just the label of the item to score on.\n\t */\n\tgetItemLabel(item: T): string | undefined;\n\n\t/**\n\t * The optional description of the item to score on.\n\t */\n\tgetItemDescription(item: T): string | undefined;\n\n\t/**\n\t * If the item is a file, the path of the file to score on.\n\t */\n\tgetItemPath(file: T): string | undefined;\n}\n\nconst PATH_IDENTITY_SCORE = 1 << 18;\nconst LABEL_PREFIX_SCORE_THRESHOLD = 1 << 17;\nconst LABEL_SCORE_THRESHOLD = 1 << 16;\n\nfunction getCacheHash(label: string, description: string | undefined, allowNonContiguousMatches: boolean, query: IPreparedQuery) {\n\tconst values = query.values ? query.values : [query];\n\tconst cacheHash = hash({\n\t\t[query.normalized]: {\n\t\t\tvalues: values.map(v => ({ value: v.normalized, expectContiguousMatch: v.expectContiguousMatch })),\n\t\t\tlabel,\n\t\t\tdescription,\n\t\t\tallowNonContiguousMatches\n\t\t}\n\t});\n\treturn cacheHash;\n}\n\nexport function scoreItemFuzzy<T>(item: T, query: IPreparedQuery, allowNonContiguousMatches: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): IItemScore {\n\tif (!item || !query.normalized) {\n\t\treturn NO_ITEM_SCORE; // we need an item and query to score on at least\n\t}\n\n\tconst label = accessor.getItemLabel(item);\n\tif (!label) {\n\t\treturn NO_ITEM_SCORE; // we need a label at least\n\t}\n\n\tconst description = accessor.getItemDescription(item);\n\n\t// in order to speed up scoring, we cache the score with a unique hash based on:\n\t// - label\n\t// - description (if provided)\n\t// - whether non-contiguous matching is enabled or not\n\t// - hash of the query (normalized) values\n\tconst cacheHash = getCacheHash(label, description, allowNonContiguousMatches, query);\n\tconst cached = cache[cacheHash];\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst itemScore = doScoreItemFuzzy(label, description, accessor.getItemPath(item), query, allowNonContiguousMatches);\n\tcache[cacheHash] = itemScore;\n\n\treturn itemScore;\n}\n\nfunction doScoreItemFuzzy(label: string, description: string | undefined, path: string | undefined, query: IPreparedQuery, allowNonContiguousMatches: boolean): IItemScore {\n\tconst preferLabelMatches = !path || !query.containsPathSeparator;\n\n\t// Treat identity matches on full path highest\n\tif (path && (isLinux ? query.pathNormalized === path : equalsIgnoreCase(query.pathNormalized, path))) {\n\t\treturn { score: PATH_IDENTITY_SCORE, labelMatch: [{ start: 0, end: label.length }], descriptionMatch: description ? [{ start: 0, end: description.length }] : undefined };\n\t}\n\n\t// Score: multiple inputs\n\tif (query.values && query.values.length > 1) {\n\t\treturn doScoreItemFuzzyMultiple(label, description, path, query.values, preferLabelMatches, allowNonContiguousMatches);\n\t}\n\n\t// Score: single input\n\treturn doScoreItemFuzzySingle(label, description, path, query, preferLabelMatches, allowNonContiguousMatches);\n}\n\nfunction doScoreItemFuzzyMultiple(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece[], preferLabelMatches: boolean, allowNonContiguousMatches: boolean): IItemScore {\n\tlet totalScore = 0;\n\tconst totalLabelMatches: IMatch[] = [];\n\tconst totalDescriptionMatches: IMatch[] = [];\n\n\tfor (const queryPiece of query) {\n\t\tconst { score, labelMatch, descriptionMatch } = doScoreItemFuzzySingle(label, description, path, queryPiece, preferLabelMatches, allowNonContiguousMatches);\n\t\tif (score === NO_MATCH) {\n\t\t\t// if a single query value does not match, return with\n\t\t\t// no score entirely, we require all queries to match\n\t\t\treturn NO_ITEM_SCORE;\n\t\t}\n\n\t\ttotalScore += score;\n\t\tif (labelMatch) {\n\t\t\ttotalLabelMatches.push(...labelMatch);\n\t\t}\n\n\t\tif (descriptionMatch) {\n\t\t\ttotalDescriptionMatches.push(...descriptionMatch);\n\t\t}\n\t}\n\n\t// if we have a score, ensure that the positions are\n\t// sorted in ascending order and distinct\n\treturn {\n\t\tscore: totalScore,\n\t\tlabelMatch: normalizeMatches(totalLabelMatches),\n\t\tdescriptionMatch: normalizeMatches(totalDescriptionMatches)\n\t};\n}\n\nfunction doScoreItemFuzzySingle(label: string, description: string | undefined, path: string | undefined, query: IPreparedQueryPiece, preferLabelMatches: boolean, allowNonContiguousMatches: boolean): IItemScore {\n\n\t// Prefer label matches if told so or we have no description\n\tif (preferLabelMatches || !description) {\n\t\tconst [labelScore, labelPositions] = scoreFuzzy(\n\t\t\tlabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch);\n\t\tif (labelScore) {\n\n\t\t\t// If we have a prefix match on the label, we give a much\n\t\t\t// higher baseScore to elevate these matches over others\n\t\t\t// This ensures that typing a file name wins over results\n\t\t\t// that are present somewhere in the label, but not the\n\t\t\t// beginning.\n\t\t\tconst labelPrefixMatch = matchesPrefix(query.normalized, label);\n\t\t\tlet baseScore: number;\n\t\t\tif (labelPrefixMatch) {\n\t\t\t\tbaseScore = LABEL_PREFIX_SCORE_THRESHOLD;\n\n\t\t\t\t// We give another boost to labels that are short, e.g. given\n\t\t\t\t// files \"window.ts\" and \"windowActions.ts\" and a query of\n\t\t\t\t// \"window\", we want \"window.ts\" to receive a higher score.\n\t\t\t\t// As such we compute the percentage the query has within the\n\t\t\t\t// label and add that to the baseScore.\n\t\t\t\tconst prefixLengthBoost = Math.round((query.normalized.length / label.length) * 100);\n\t\t\t\tbaseScore += prefixLengthBoost;\n\t\t\t} else {\n\t\t\t\tbaseScore = LABEL_SCORE_THRESHOLD;\n\t\t\t}\n\n\t\t\treturn { score: baseScore + labelScore, labelMatch: labelPrefixMatch || createMatches(labelPositions) };\n\t\t}\n\t}\n\n\t// Finally compute description + label scores if we have a description\n\tif (description) {\n\t\tlet descriptionPrefix = description;\n\t\tif (!!path) {\n\t\t\tdescriptionPrefix = `${description}${sep}`; // assume this is a file path\n\t\t}\n\n\t\tconst descriptionPrefixLength = descriptionPrefix.length;\n\t\tconst descriptionAndLabel = `${descriptionPrefix}${label}`;\n\n\t\tconst [labelDescriptionScore, labelDescriptionPositions] = scoreFuzzy(\n\t\t\tdescriptionAndLabel,\n\t\t\tquery.normalized,\n\t\t\tquery.normalizedLowercase,\n\t\t\tallowNonContiguousMatches && !query.expectContiguousMatch);\n\t\tif (labelDescriptionScore) {\n\t\t\tconst labelDescriptionMatches = createMatches(labelDescriptionPositions);\n\t\t\tconst labelMatch: IMatch[] = [];\n\t\t\tconst descriptionMatch: IMatch[] = [];\n\n\t\t\t// We have to split the matches back onto the label and description portions\n\t\t\tlabelDescriptionMatches.forEach(h => {\n\n\t\t\t\t// Match overlaps label and description part, we need to split it up\n\t\t\t\tif (h.start < descriptionPrefixLength && h.end > descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: 0, end: h.end - descriptionPrefixLength });\n\t\t\t\t\tdescriptionMatch.push({ start: h.start, end: descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on label part\n\t\t\t\telse if (h.start >= descriptionPrefixLength) {\n\t\t\t\t\tlabelMatch.push({ start: h.start - descriptionPrefixLength, end: h.end - descriptionPrefixLength });\n\t\t\t\t}\n\n\t\t\t\t// Match on description part\n\t\t\t\telse {\n\t\t\t\t\tdescriptionMatch.push(h);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn { score: labelDescriptionScore, labelMatch, descriptionMatch };\n\t\t}\n\t}\n\n\treturn NO_ITEM_SCORE;\n}\n\nfunction createMatches(offsets: number[] | undefined): IMatch[] {\n\tconst ret: IMatch[] = [];\n\tif (!offsets) {\n\t\treturn ret;\n\t}\n\n\tlet last: IMatch | undefined;\n\tfor (const pos of offsets) {\n\t\tif (last && last.end === pos) {\n\t\t\tlast.end += 1;\n\t\t} else {\n\t\t\tlast = { start: pos, end: pos + 1 };\n\t\t\tret.push(last);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nfunction normalizeMatches(matches: IMatch[]): IMatch[] {\n\n\t// sort matches by start to be able to normalize\n\tconst sortedMatches = matches.sort((matchA, matchB) => {\n\t\treturn matchA.start - matchB.start;\n\t});\n\n\t// merge matches that overlap\n\tconst normalizedMatches: IMatch[] = [];\n\tlet currentMatch: IMatch | undefined = undefined;\n\tfor (const match of sortedMatches) {\n\n\t\t// if we have no current match or the matches\n\t\t// do not overlap, we take it as is and remember\n\t\t// it for future merging\n\t\tif (!currentMatch || !matchOverlaps(currentMatch, match)) {\n\t\t\tcurrentMatch = match;\n\t\t\tnormalizedMatches.push(match);\n\t\t}\n\n\t\t// otherwise we merge the matches\n\t\telse {\n\t\t\tcurrentMatch.start = Math.min(currentMatch.start, match.start);\n\t\t\tcurrentMatch.end = Math.max(currentMatch.end, match.end);\n\t\t}\n\t}\n\n\treturn normalizedMatches;\n}\n\nfunction matchOverlaps(matchA: IMatch, matchB: IMatch): boolean {\n\tif (matchA.end < matchB.start) {\n\t\treturn false;\t// A ends before B starts\n\t}\n\n\tif (matchB.end < matchA.start) {\n\t\treturn false; // B ends before A starts\n\t}\n\n\treturn true;\n}\n\n//#endregion\n\n\n//#region Comparers\n\nexport function compareItemsByFuzzyScore<T>(itemA: T, itemB: T, query: IPreparedQuery, allowNonContiguousMatches: boolean, accessor: IItemAccessor<T>, cache: FuzzyScorerCache): number {\n\tconst itemScoreA = scoreItemFuzzy(itemA, query, allowNonContiguousMatches, accessor, cache);\n\tconst itemScoreB = scoreItemFuzzy(itemB, query, allowNonContiguousMatches, accessor, cache);\n\n\tconst scoreA = itemScoreA.score;\n\tconst scoreB = itemScoreB.score;\n\n\t// 1.) identity matches have highest score\n\tif (scoreA === PATH_IDENTITY_SCORE || scoreB === PATH_IDENTITY_SCORE) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA === PATH_IDENTITY_SCORE ? -1 : 1;\n\t\t}\n\t}\n\n\t// 2.) matches on label are considered higher compared to label+description matches\n\tif (scoreA > LABEL_SCORE_THRESHOLD || scoreB > LABEL_SCORE_THRESHOLD) {\n\t\tif (scoreA !== scoreB) {\n\t\t\treturn scoreA > scoreB ? -1 : 1;\n\t\t}\n\n\t\t// prefer more compact matches over longer in label (unless this is a prefix match where\n\t\t// longer prefix matches are actually preferred)\n\t\tif (scoreA < LABEL_PREFIX_SCORE_THRESHOLD && scoreB < LABEL_PREFIX_SCORE_THRESHOLD) {\n\t\t\tconst comparedByMatchLength = compareByMatchLength(itemScoreA.labelMatch, itemScoreB.labelMatch);\n\t\t\tif (comparedByMatchLength !== 0) {\n\t\t\t\treturn comparedByMatchLength;\n\t\t\t}\n\t\t}\n\n\t\t// prefer shorter labels over longer labels\n\t\tconst labelA = accessor.getItemLabel(itemA) || '';\n\t\tconst labelB = accessor.getItemLabel(itemB) || '';\n\t\tif (labelA.length !== labelB.length) {\n\t\t\treturn labelA.length - labelB.length;\n\t\t}\n\t}\n\n\t// 3.) compare by score in label+description\n\tif (scoreA !== scoreB) {\n\t\treturn scoreA > scoreB ? -1 : 1;\n\t}\n\n\t// 4.) scores are identical: prefer matches in label over non-label matches\n\tconst itemAHasLabelMatches = Array.isArray(itemScoreA.labelMatch) && itemScoreA.labelMatch.length > 0;\n\tconst itemBHasLabelMatches = Array.isArray(itemScoreB.labelMatch) && itemScoreB.labelMatch.length > 0;\n\tif (itemAHasLabelMatches && !itemBHasLabelMatches) {\n\t\treturn -1;\n\t} else if (itemBHasLabelMatches && !itemAHasLabelMatches) {\n\t\treturn 1;\n\t}\n\n\t// 5.) scores are identical: prefer more compact matches (label and description)\n\tconst itemAMatchDistance = computeLabelAndDescriptionMatchDistance(itemA, itemScoreA, accessor);\n\tconst itemBMatchDistance = computeLabelAndDescriptionMatchDistance(itemB, itemScoreB, accessor);\n\tif (itemAMatchDistance && itemBMatchDistance && itemAMatchDistance !== itemBMatchDistance) {\n\t\treturn itemBMatchDistance > itemAMatchDistance ? -1 : 1;\n\t}\n\n\t// 6.) scores are identical: start to use the fallback compare\n\treturn fallbackCompare(itemA, itemB, query, accessor);\n}\n\nfunction computeLabelAndDescriptionMatchDistance<T>(item: T, score: IItemScore, accessor: IItemAccessor<T>): number {\n\tlet matchStart: number = -1;\n\tlet matchEnd: number = -1;\n\n\t// If we have description matches, the start is first of description match\n\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchStart = score.descriptionMatch[0].start;\n\t}\n\n\t// Otherwise, the start is the first label match\n\telse if (score.labelMatch && score.labelMatch.length) {\n\t\tmatchStart = score.labelMatch[0].start;\n\t}\n\n\t// If we have label match, the end is the last label match\n\t// If we had a description match, we add the length of the description\n\t// as offset to the end to indicate this.\n\tif (score.labelMatch && score.labelMatch.length) {\n\t\tmatchEnd = score.labelMatch[score.labelMatch.length - 1].end;\n\t\tif (score.descriptionMatch && score.descriptionMatch.length) {\n\t\t\tconst itemDescription = accessor.getItemDescription(item);\n\t\t\tif (itemDescription) {\n\t\t\t\tmatchEnd += itemDescription.length;\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have just a description match, the end is the last description match\n\telse if (score.descriptionMatch && score.descriptionMatch.length) {\n\t\tmatchEnd = score.descriptionMatch[score.descriptionMatch.length - 1].end;\n\t}\n\n\treturn matchEnd - matchStart;\n}\n\nfunction compareByMatchLength(matchesA?: IMatch[], matchesB?: IMatch[]): number {\n\tif ((!matchesA && !matchesB) || ((!matchesA || !matchesA.length) && (!matchesB || !matchesB.length))) {\n\t\treturn 0; // make sure to not cause bad comparing when matches are not provided\n\t}\n\n\tif (!matchesB || !matchesB.length) {\n\t\treturn -1;\n\t}\n\n\tif (!matchesA || !matchesA.length) {\n\t\treturn 1;\n\t}\n\n\t// Compute match length of A (first to last match)\n\tconst matchStartA = matchesA[0].start;\n\tconst matchEndA = matchesA[matchesA.length - 1].end;\n\tconst matchLengthA = matchEndA - matchStartA;\n\n\t// Compute match length of B (first to last match)\n\tconst matchStartB = matchesB[0].start;\n\tconst matchEndB = matchesB[matchesB.length - 1].end;\n\tconst matchLengthB = matchEndB - matchStartB;\n\n\t// Prefer shorter match length\n\treturn matchLengthA === matchLengthB ? 0 : matchLengthB < matchLengthA ? 1 : -1;\n}\n\nfunction fallbackCompare<T>(itemA: T, itemB: T, query: IPreparedQuery, accessor: IItemAccessor<T>): number {\n\n\t// check for label + description length and prefer shorter\n\tconst labelA = accessor.getItemLabel(itemA) || '';\n\tconst labelB = accessor.getItemLabel(itemB) || '';\n\n\tconst descriptionA = accessor.getItemDescription(itemA);\n\tconst descriptionB = accessor.getItemDescription(itemB);\n\n\tconst labelDescriptionALength = labelA.length + (descriptionA ? descriptionA.length : 0);\n\tconst labelDescriptionBLength = labelB.length + (descriptionB ? descriptionB.length : 0);\n\n\tif (labelDescriptionALength !== labelDescriptionBLength) {\n\t\treturn labelDescriptionALength - labelDescriptionBLength;\n\t}\n\n\t// check for path length and prefer shorter\n\tconst pathA = accessor.getItemPath(itemA);\n\tconst pathB = accessor.getItemPath(itemB);\n\n\tif (pathA && pathB && pathA.length !== pathB.length) {\n\t\treturn pathA.length - pathB.length;\n\t}\n\n\t// 7.) finally we have equal scores and equal length, we fallback to comparer\n\n\t// compare by label\n\tif (labelA !== labelB) {\n\t\treturn compareAnything(labelA, labelB, query.normalized);\n\t}\n\n\t// compare by description\n\tif (descriptionA && descriptionB && descriptionA !== descriptionB) {\n\t\treturn compareAnything(descriptionA, descriptionB, query.normalized);\n\t}\n\n\t// compare by path\n\tif (pathA && pathB && pathA !== pathB) {\n\t\treturn compareAnything(pathA, pathB, query.normalized);\n\t}\n\n\t// equal\n\treturn 0;\n}\n\n//#endregion\n\n\n//#region Query Normalizer\n\nexport interface IPreparedQueryPiece {\n\n\t/**\n\t * The original query as provided as input.\n\t */\n\toriginal: string;\n\toriginalLowercase: string;\n\n\t/**\n\t * Original normalized to platform separators:\n\t * - Windows: \\\n\t * - Posix: /\n\t */\n\tpathNormalized: string;\n\n\t/**\n\t * In addition to the normalized path, will have\n\t * whitespace and wildcards removed.\n\t */\n\tnormalized: string;\n\tnormalizedLowercase: string;\n\n\t/**\n\t * The query is wrapped in quotes which means\n\t * this query must be a substring of the input.\n\t * In other words, no fuzzy matching is used.\n\t */\n\texpectContiguousMatch: boolean;\n}\n\nexport interface IPreparedQuery extends IPreparedQueryPiece {\n\n\t/**\n\t * Query split by spaces into pieces.\n\t */\n\tvalues: IPreparedQueryPiece[] | undefined;\n\n\t/**\n\t * Whether the query contains path separator(s) or not.\n\t */\n\tcontainsPathSeparator: boolean;\n}\n\n/*\n * If a query is wrapped in quotes, the user does not want to\n * use fuzzy search for this query.\n */\nfunction queryExpectsExactMatch(query: string) {\n\treturn query.startsWith('\"') && query.endsWith('\"');\n}\n\n/**\n * Helper function to prepare a search value for scoring by removing unwanted characters\n * and allowing to score on multiple pieces separated by whitespace character.\n */\nconst MULTIPLE_QUERY_VALUES_SEPARATOR = ' ';\nexport function prepareQuery(original: string): IPreparedQuery {\n\tif (typeof original !== 'string') {\n\t\toriginal = '';\n\t}\n\n\tconst originalLowercase = original.toLowerCase();\n\tconst { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);\n\tconst containsPathSeparator = pathNormalized.indexOf(sep) >= 0;\n\tconst expectExactMatch = queryExpectsExactMatch(original);\n\n\tlet values: IPreparedQueryPiece[] | undefined = undefined;\n\n\tconst originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);\n\tif (originalSplit.length > 1) {\n\t\tfor (const originalPiece of originalSplit) {\n\t\t\tconst expectExactMatchPiece = queryExpectsExactMatch(originalPiece);\n\t\t\tconst {\n\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\tnormalizedLowercase: normalizedLowercasePiece\n\t\t\t} = normalizeQuery(originalPiece);\n\n\t\t\tif (normalizedPiece) {\n\t\t\t\tif (!values) {\n\t\t\t\t\tvalues = [];\n\t\t\t\t}\n\n\t\t\t\tvalues.push({\n\t\t\t\t\toriginal: originalPiece,\n\t\t\t\t\toriginalLowercase: originalPiece.toLowerCase(),\n\t\t\t\t\tpathNormalized: pathNormalizedPiece,\n\t\t\t\t\tnormalized: normalizedPiece,\n\t\t\t\t\tnormalizedLowercase: normalizedLowercasePiece,\n\t\t\t\t\texpectContiguousMatch: expectExactMatchPiece\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };\n}\n\nfunction normalizeQuery(original: string): { pathNormalized: string; normalized: string; normalizedLowercase: string } {\n\tlet pathNormalized: string;\n\tif (isWindows) {\n\t\tpathNormalized = original.replace(/\\//g, sep); // Help Windows users to search for paths when using slash\n\t} else {\n\t\tpathNormalized = original.replace(/\\\\/g, sep); // Help macOS/Linux users to search for paths when using backslash\n\t}\n\n\t// we remove quotes here because quotes are used for exact match search\n\tconst normalized = stripWildcards(pathNormalized).replace(/\\s|\"/g, '');\n\n\treturn {\n\t\tpathNormalized,\n\t\tnormalized,\n\t\tnormalizedLowercase: normalized.toLowerCase()\n\t};\n}\n\nexport function pieceToQuery(piece: IPreparedQueryPiece): IPreparedQuery;\nexport function pieceToQuery(pieces: IPreparedQueryPiece[]): IPreparedQuery;\nexport function pieceToQuery(arg1: IPreparedQueryPiece | IPreparedQueryPiece[]): IPreparedQuery {\n\tif (Array.isArray(arg1)) {\n\t\treturn prepareQuery(arg1.map(piece => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));\n\t}\n\n\treturn prepareQuery(arg1.original);\n}\n\n//#endregion\n"]}