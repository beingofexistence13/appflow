{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/resources.ts"],"names":[],"mappings":"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","file":"resources.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n"]}