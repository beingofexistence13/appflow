{"version":3,"sources":["file:///workspace/appflow/src/vs/base/common/labels.ts"],"names":[],"mappings":"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","file":"labels.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { firstOrDefault } from 'vs/base/common/arrays';\nimport { hasDriveLetter, toSlashes } from 'vs/base/common/extpath';\nimport { posix, sep, win32 } from 'vs/base/common/path';\nimport { isMacintosh, isWindows, OperatingSystem, OS } from 'vs/base/common/platform';\nimport { extUri, extUriIgnorePathCase } from 'vs/base/common/resources';\nimport { rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\n\nexport interface IPathLabelFormatting {\n\n\t/**\n\t * The OS the path label is from to produce a label\n\t * that matches OS expectations.\n\t */\n\treadonly os: OperatingSystem;\n\n\t/**\n\t * Whether to add a `~` when the path is in the\n\t * user home directory.\n\t *\n\t * Note: this only applies to Linux, macOS but not\n\t * Windows.\n\t */\n\treadonly tildify?: IUserHomeProvider;\n\n\t/**\n\t * Whether to convert to a relative path if the path\n\t * is within any of the opened workspace folders.\n\t */\n\treadonly relative?: IRelativePathProvider;\n}\n\nexport interface IRelativePathProvider {\n\n\t/**\n\t * Whether to not add a prefix when in multi-root workspace.\n\t */\n\treadonly noPrefix?: boolean;\n\n\tgetWorkspace(): { folders: { uri: URI; name?: string }[] };\n\tgetWorkspaceFolder(resource: URI): { uri: URI; name?: string } | null;\n}\n\nexport interface IUserHomeProvider {\n\tuserHome: URI;\n}\n\nexport function getPathLabel(resource: URI, formatting: IPathLabelFormatting): string {\n\tconst { os, tildify: tildifier, relative: relatifier } = formatting;\n\n\t// return early with a relative path if we can resolve one\n\tif (relatifier) {\n\t\tconst relativePath = getRelativePathLabel(resource, relatifier, os);\n\t\tif (typeof relativePath === 'string') {\n\t\t\treturn relativePath;\n\t\t}\n\t}\n\n\t// otherwise try to resolve a absolute path label and\n\t// apply target OS standard path separators if target\n\t// OS differs from actual OS we are running in\n\tlet absolutePath = resource.fsPath;\n\tif (os === OperatingSystem.Windows && !isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\//g, '\\\\');\n\t} else if (os !== OperatingSystem.Windows && isWindows) {\n\t\tabsolutePath = absolutePath.replace(/\\\\/g, '/');\n\t}\n\n\t// macOS/Linux: tildify with provided user home directory\n\tif (os !== OperatingSystem.Windows && tildifier?.userHome) {\n\t\tconst userHome = tildifier.userHome.fsPath;\n\n\t\t// This is a bit of a hack, but in order to figure out if the\n\t\t// resource is in the user home, we need to make sure to convert it\n\t\t// to a user home resource. We cannot assume that the resource is\n\t\t// already a user home resource.\n\t\tlet userHomeCandidate: string;\n\t\tif (resource.scheme !== tildifier.userHome.scheme && resource.path.startsWith(posix.sep)) {\n\t\t\tuserHomeCandidate = tildifier.userHome.with({ path: resource.path }).fsPath;\n\t\t} else {\n\t\t\tuserHomeCandidate = resource.fsPath;\n\t\t}\n\n\t\tabsolutePath = tildify(userHomeCandidate, userHome, os);\n\t}\n\n\t// normalize\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\treturn pathLib.normalize(normalizeDriveLetter(absolutePath, os === OperatingSystem.Windows));\n}\n\nfunction getRelativePathLabel(resource: URI, relativePathProvider: IRelativePathProvider, os: OperatingSystem): string | undefined {\n\tconst pathLib = os === OperatingSystem.Windows ? win32 : posix;\n\tconst extUriLib = os === OperatingSystem.Linux ? extUri : extUriIgnorePathCase;\n\n\tconst workspace = relativePathProvider.getWorkspace();\n\tconst firstFolder = firstOrDefault(workspace.folders);\n\tif (!firstFolder) {\n\t\treturn undefined;\n\t}\n\n\t// This is a bit of a hack, but in order to figure out the folder\n\t// the resource belongs to, we need to make sure to convert it\n\t// to a workspace resource. We cannot assume that the resource is\n\t// already matching the workspace.\n\tif (resource.scheme !== firstFolder.uri.scheme && resource.path.startsWith(posix.sep)) {\n\t\tresource = firstFolder.uri.with({ path: resource.path });\n\t}\n\n\tconst folder = relativePathProvider.getWorkspaceFolder(resource);\n\tif (!folder) {\n\t\treturn undefined;\n\t}\n\n\tlet relativePathLabel: string | undefined = undefined;\n\tif (extUriLib.isEqual(folder.uri, resource)) {\n\t\trelativePathLabel = ''; // no label if paths are identical\n\t} else {\n\t\trelativePathLabel = extUriLib.relativePath(folder.uri, resource) ?? '';\n\t}\n\n\t// normalize\n\tif (relativePathLabel) {\n\t\trelativePathLabel = pathLib.normalize(relativePathLabel);\n\t}\n\n\t// always show root basename if there are multiple folders\n\tif (workspace.folders.length > 1 && !relativePathProvider.noPrefix) {\n\t\tconst rootName = folder.name ? folder.name : extUriLib.basenameOrAuthority(folder.uri);\n\t\trelativePathLabel = relativePathLabel ? `${rootName} â€¢ ${relativePathLabel}` : rootName;\n\t}\n\n\treturn relativePathLabel;\n}\n\nexport function normalizeDriveLetter(path: string, isWindowsOS: boolean = isWindows): string {\n\tif (hasDriveLetter(path, isWindowsOS)) {\n\t\treturn path.charAt(0).toUpperCase() + path.slice(1);\n\t}\n\n\treturn path;\n}\n\nlet normalizedUserHomeCached: { original: string; normalized: string } = Object.create(null);\nexport function tildify(path: string, userHome: string, os = OS): string {\n\tif (os === OperatingSystem.Windows || !path || !userHome) {\n\t\treturn path; // unsupported on Windows\n\t}\n\n\tlet normalizedUserHome = normalizedUserHomeCached.original === userHome ? normalizedUserHomeCached.normalized : undefined;\n\tif (!normalizedUserHome) {\n\t\tnormalizedUserHome = userHome;\n\t\tif (isWindows) {\n\t\t\tnormalizedUserHome = toSlashes(normalizedUserHome); // make sure that the path is POSIX normalized on Windows\n\t\t}\n\t\tnormalizedUserHome = `${rtrim(normalizedUserHome, posix.sep)}${posix.sep}`;\n\t\tnormalizedUserHomeCached = { original: userHome, normalized: normalizedUserHome };\n\t}\n\n\tlet normalizedPath = path;\n\tif (isWindows) {\n\t\tnormalizedPath = toSlashes(normalizedPath); // make sure that the path is POSIX normalized on Windows\n\t}\n\n\t// Linux: case sensitive, macOS: case insensitive\n\tif (os === OperatingSystem.Linux ? normalizedPath.startsWith(normalizedUserHome) : startsWithIgnoreCase(normalizedPath, normalizedUserHome)) {\n\t\treturn `~/${normalizedPath.substr(normalizedUserHome.length)}`;\n\t}\n\n\treturn path;\n}\n\nexport function untildify(path: string, userHome: string): string {\n\treturn path.replace(/^~($|\\/|\\\\)/, `${userHome}$1`);\n}\n\n/**\n * Shortens the paths but keeps them easy to distinguish.\n * Replaces not important parts with ellipsis.\n * Every shorten path matches only one original path and vice versa.\n *\n * Algorithm for shortening paths is as follows:\n * 1. For every path in list, find unique substring of that path.\n * 2. Unique substring along with ellipsis is shortened path of that path.\n * 3. To find unique substring of path, consider every segment of length from 1 to path.length of path from end of string\n *    and if present segment is not substring to any other paths then present segment is unique path,\n *    else check if it is not present as suffix of any other path and present segment is suffix of path itself,\n *    if it is true take present segment as unique path.\n * 4. Apply ellipsis to unique segment according to whether segment is present at start/in-between/end of path.\n *\n * Example 1\n * 1. consider 2 paths i.e. ['a\\\\b\\\\c\\\\d', 'a\\\\f\\\\b\\\\c\\\\d']\n * 2. find unique path of first path,\n * \ta. 'd' is present in path2 and is suffix of path2, hence not unique of present path.\n * \tb. 'c' is present in path2 and 'c' is not suffix of present path, similarly for 'b' and 'a' also.\n * \tc. 'd\\\\c' is suffix of path2.\n *  d. 'b\\\\c' is not suffix of present path.\n *  e. 'a\\\\b' is not present in path2, hence unique path is 'a\\\\b...'.\n * 3. for path2, 'f' is not present in path1 hence unique is '...\\\\f\\\\...'.\n *\n * Example 2\n * 1. consider 2 paths i.e. ['a\\\\b', 'a\\\\b\\\\c'].\n * \ta. Even if 'b' is present in path2, as 'b' is suffix of path1 and is not suffix of path2, unique path will be '...\\\\b'.\n * 2. for path2, 'c' is not present in path1 hence unique path is '..\\\\c'.\n */\nconst ellipsis = '\\u2026';\nconst unc = '\\\\\\\\';\nconst home = '~';\nexport function shorten(paths: string[], pathSeparator: string = sep): string[] {\n\tconst shortenedPaths: string[] = new Array(paths.length);\n\n\t// for every path\n\tlet match = false;\n\tfor (let pathIndex = 0; pathIndex < paths.length; pathIndex++) {\n\t\tconst originalPath = paths[pathIndex];\n\n\t\tif (originalPath === '') {\n\t\t\tshortenedPaths[pathIndex] = `.${pathSeparator}`;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!originalPath) {\n\t\t\tshortenedPaths[pathIndex] = originalPath;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmatch = true;\n\n\t\t// trim for now and concatenate unc path (e.g. \\\\network) or root path (/etc, ~/etc) later\n\t\tlet prefix = '';\n\t\tlet trimmedPath = originalPath;\n\t\tif (trimmedPath.indexOf(unc) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(unc) + unc.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(unc) + unc.length);\n\t\t} else if (trimmedPath.indexOf(pathSeparator) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(pathSeparator) + pathSeparator.length);\n\t\t} else if (trimmedPath.indexOf(home) === 0) {\n\t\t\tprefix = trimmedPath.substr(0, trimmedPath.indexOf(home) + home.length);\n\t\t\ttrimmedPath = trimmedPath.substr(trimmedPath.indexOf(home) + home.length);\n\t\t}\n\n\t\t// pick the first shortest subpath found\n\t\tconst segments: string[] = trimmedPath.split(pathSeparator);\n\t\tfor (let subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {\n\t\t\tfor (let start = segments.length - subpathLength; match && start >= 0; start--) {\n\t\t\t\tmatch = false;\n\t\t\t\tlet subpath = segments.slice(start, start + subpathLength).join(pathSeparator);\n\n\t\t\t\t// that is unique to any other path\n\t\t\t\tfor (let otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {\n\n\t\t\t\t\t// suffix subpath treated specially as we consider no match 'x' and 'x/...'\n\t\t\t\t\tif (otherPathIndex !== pathIndex && paths[otherPathIndex] && paths[otherPathIndex].indexOf(subpath) > -1) {\n\t\t\t\t\t\tconst isSubpathEnding: boolean = (start + subpathLength === segments.length);\n\n\t\t\t\t\t\t// Adding separator as prefix for subpath, such that 'endsWith(src, trgt)' considers subpath as directory name instead of plain string.\n\t\t\t\t\t\t// prefix is not added when either subpath is root directory or path[otherPathIndex] does not have multiple directories.\n\t\t\t\t\t\tconst subpathWithSep: string = (start > 0 && paths[otherPathIndex].indexOf(pathSeparator) > -1) ? pathSeparator + subpath : subpath;\n\t\t\t\t\t\tconst isOtherPathEnding: boolean = paths[otherPathIndex].endsWith(subpathWithSep);\n\n\t\t\t\t\t\tmatch = !isSubpathEnding || isOtherPathEnding;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// found unique subpath\n\t\t\t\tif (!match) {\n\t\t\t\t\tlet result = '';\n\n\t\t\t\t\t// preserve disk drive or root prefix\n\t\t\t\t\tif (segments[0].endsWith(':') || prefix !== '') {\n\t\t\t\t\t\tif (start === 1) {\n\t\t\t\t\t\t\t// extend subpath to include disk drive prefix\n\t\t\t\t\t\t\tstart = 0;\n\t\t\t\t\t\t\tsubpathLength++;\n\t\t\t\t\t\t\tsubpath = segments[0] + pathSeparator + subpath;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\t\tresult = segments[0] + pathSeparator;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult = prefix + result;\n\t\t\t\t\t}\n\n\t\t\t\t\t// add ellipsis at the beginning if needed\n\t\t\t\t\tif (start > 0) {\n\t\t\t\t\t\tresult = result + ellipsis + pathSeparator;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult = result + subpath;\n\n\t\t\t\t\t// add ellipsis at the end if needed\n\t\t\t\t\tif (start + subpathLength < segments.length) {\n\t\t\t\t\t\tresult = result + pathSeparator + ellipsis;\n\t\t\t\t\t}\n\n\t\t\t\t\tshortenedPaths[pathIndex] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (match) {\n\t\t\tshortenedPaths[pathIndex] = originalPath; // use original path if no unique subpaths found\n\t\t}\n\t}\n\n\treturn shortenedPaths;\n}\n\nexport interface ISeparator {\n\tlabel: string;\n}\n\nenum Type {\n\tTEXT,\n\tVARIABLE,\n\tSEPARATOR\n}\n\ninterface ISegment {\n\tvalue: string;\n\ttype: Type;\n}\n\n/**\n * Helper to insert values for specific template variables into the string. E.g. \"this $(is) a $(template)\" can be\n * passed to this function together with an object that maps \"is\" and \"template\" to strings to have them replaced.\n * @param value string to which template is applied\n * @param values the values of the templates to use\n */\nexport function template(template: string, values: { [key: string]: string | ISeparator | undefined | null } = Object.create(null)): string {\n\tconst segments: ISegment[] = [];\n\n\tlet inVariable = false;\n\tlet curVal = '';\n\tfor (const char of template) {\n\t\t// Beginning of variable\n\t\tif (char === '$' || (inVariable && char === '{')) {\n\t\t\tif (curVal) {\n\t\t\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = true;\n\t\t}\n\n\t\t// End of variable\n\t\telse if (char === '}' && inVariable) {\n\t\t\tconst resolved = values[curVal];\n\n\t\t\t// Variable\n\t\t\tif (typeof resolved === 'string') {\n\t\t\t\tif (resolved.length) {\n\t\t\t\t\tsegments.push({ value: resolved, type: Type.VARIABLE });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Separator\n\t\t\telse if (resolved) {\n\t\t\t\tconst prevSegment = segments[segments.length - 1];\n\t\t\t\tif (!prevSegment || prevSegment.type !== Type.SEPARATOR) {\n\t\t\t\t\tsegments.push({ value: resolved.label, type: Type.SEPARATOR }); // prevent duplicate separators\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurVal = '';\n\t\t\tinVariable = false;\n\t\t}\n\n\t\t// Text or Variable Name\n\t\telse {\n\t\t\tcurVal += char;\n\t\t}\n\t}\n\n\t// Tail\n\tif (curVal && !inVariable) {\n\t\tsegments.push({ value: curVal, type: Type.TEXT });\n\t}\n\n\treturn segments.filter((segment, index) => {\n\n\t\t// Only keep separator if we have values to the left and right\n\t\tif (segment.type === Type.SEPARATOR) {\n\t\t\tconst left = segments[index - 1];\n\t\t\tconst right = segments[index + 1];\n\n\t\t\treturn [left, right].every(segment => segment && (segment.type === Type.VARIABLE || segment.type === Type.TEXT) && segment.value.length > 0);\n\t\t}\n\n\t\t// accept any TEXT and VARIABLE\n\t\treturn true;\n\t}).map(segment => segment.value).join('');\n}\n\n/**\n * Handles mnemonics for menu items. Depending on OS:\n * - Windows: Supported via & character (replace && with &)\n * -   Linux: Supported via & character (replace && with &)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicMenuLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '').replace(/&/g, isMacintosh ? '&' : '&&');\n\t}\n\n\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n}\n\n/**\n * Handles mnemonics for buttons. Depending on OS:\n * - Windows: Supported via & character (replace && with & and & with && for escaping)\n * -   Linux: Supported via _ character (replace && with _)\n * -   macOS: Unsupported (replace && with empty string)\n */\nexport function mnemonicButtonLabel(label: string, forceDisableMnemonics?: boolean): string {\n\tif (isMacintosh || forceDisableMnemonics) {\n\t\treturn label.replace(/\\(&&\\w\\)|&&/g, '');\n\t}\n\n\tif (isWindows) {\n\t\treturn label.replace(/&&|&/g, m => m === '&' ? '&&' : '&');\n\t}\n\n\treturn label.replace(/&&/g, '_');\n}\n\nexport function unmnemonicLabel(label: string): string {\n\treturn label.replace(/&/g, '&&');\n}\n\n/**\n * Splits a recent label in name and parent path, supporting both '/' and '\\' and workspace suffixes\n */\nexport function splitRecentLabel(recentLabel: string) {\n\tif (recentLabel.endsWith(']')) {\n\t\t// label with workspace suffix\n\t\tconst lastIndexOfSquareBracket = recentLabel.lastIndexOf(' [', recentLabel.length - 2);\n\t\tif (lastIndexOfSquareBracket !== -1) {\n\t\t\tconst split = splitName(recentLabel.substring(0, lastIndexOfSquareBracket));\n\t\t\treturn { name: split.name, parentPath: split.parentPath + recentLabel.substring(lastIndexOfSquareBracket) };\n\t\t}\n\t}\n\treturn splitName(recentLabel);\n}\n\nfunction splitName(fullPath: string): { name: string; parentPath: string } {\n\tconst p = fullPath.indexOf('/') !== -1 ? posix : win32;\n\tconst name = p.basename(fullPath);\n\tconst parentPath = p.dirname(fullPath);\n\tif (name.length) {\n\t\treturn { name, parentPath };\n\t}\n\t// only the root segment\n\treturn { name: parentPath, parentPath: '' };\n}\n"]}