{"version":3,"sources":["file:///workspace/appflow/src/vs/platform/terminal/common/capabilities/capabilities.ts","vs/platform/terminal/common/capabilities/capabilities.ts"],"names":[],"mappings":"AAAA;;;gGAGgG;;;;;IAsChG;;;OAGG;IACH,IAAkB,kBA2BjB;IA3BD,WAAkB,kBAAkB;QACnC;;;WAGG;QACH,2EAAY,CAAA;QACZ;;WAEG;QACH,qFAAiB,CAAA;QACjB;;WAEG;QACH,mFAAgB,CAAA;QAChB;;;;WAIG;QACH,iGAAuB,CAAA;QAEvB;;;;WAIG;QACH,yFAAmB,CAAA;IACpB,CAAC,EA3BiB,kBAAkB,kCAAlB,kBAAkB,QA2BnC;IAwED,IAAkB,yBAGjB;IAHD,WAAkB,yBAAyB;QAC1C,gDAAmB,CAAA;QACnB,sEAAyC,CAAA;IAC1C,CAAC,EAHiB,yBAAyB,yCAAzB,yBAAyB,QAG1C","file":"capabilities.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { ICurrentPartialCommand } from 'vs/platform/terminal/common/capabilities/commandDetectionCapability';\nimport { ITerminalOutputMatch, ITerminalOutputMatcher } from 'vs/platform/terminal/common/terminal';\nimport { ReplayEntry } from 'vs/platform/terminal/common/terminalProcess';\n\ninterface IEvent<T, U = void> {\n\t(listener: (arg1: T, arg2: U) => any): IDisposable;\n}\n\nexport interface IMarker extends IDisposable {\n\t/**\n\t * A unique identifier for this marker.\n\t */\n\treadonly id: number;\n\n\t/**\n\t * Whether this marker is disposed.\n\t */\n\treadonly isDisposed: boolean;\n\n\t/**\n\t * The actual line index in the buffer at this point in time. This is set to\n\t * -1 if the marker has been disposed.\n\t */\n\treadonly line: number;\n\n\t/**\n\t * Event listener to get notified when the marker gets disposed. Automatic disposal\n\t * might happen for a marker, that got invalidated by scrolling out or removal of\n\t * a line from the buffer.\n\t */\n\tonDispose: IEvent<void>;\n}\n\n\n/**\n * Primarily driven by the shell integration feature, a terminal capability is the mechanism for\n * progressively enhancing various features that may not be supported in all terminals/shells.\n */\nexport const enum TerminalCapability {\n\t/**\n\t * The terminal can reliably detect the current working directory as soon as the change happens\n\t * within the buffer.\n\t */\n\tCwdDetection,\n\t/**\n\t * The terminal can reliably detect the current working directory when requested.\n\t */\n\tNaiveCwdDetection,\n\t/**\n\t * The terminal can reliably identify prompts, commands and command outputs within the buffer.\n\t */\n\tCommandDetection,\n\t/**\n\t * The terminal can often identify prompts, commands and command outputs within the buffer. It\n\t * may not be so good at remembering the position of commands that ran in the past. This state\n\t * may be enabled when something goes wrong or when using conpty for example.\n\t */\n\tPartialCommandDetection,\n\n\t/**\n\t * Manages buffer marks that can be used for terminal navigation. The source of\n\t * the request (task, debug, etc) provides an ID, optional marker, hoverMessage, and hidden property. When\n\t * hidden is not provided, a generic decoration is added to the buffer and overview ruler.\n\t */\n\tBufferMarkDetection\n}\n\n/**\n * An object that keeps track of additional capabilities and their implementations for features that\n * are not available for all terminals.\n */\nexport interface ITerminalCapabilityStore {\n\t/**\n\t * An iterable of all capabilities in the store.\n\t */\n\treadonly items: IterableIterator<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is added. The event data for this is only the\n\t * {@link TerminalCapability} type, use {@link onDidAddCapability} to access the actual\n\t * capability.\n\t */\n\treadonly onDidAddCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is removed. The event data for this is only the\n\t * {@link TerminalCapability} type, use {@link onDidAddCapability} to access the actual\n\t * capability.\n\t */\n\treadonly onDidRemoveCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is added.\n\t */\n\treadonly onDidAddCapability: Event<TerminalCapabilityChangeEvent<any>>;\n\n\t/**\n\t * Fired when a capability is removed.\n\t */\n\treadonly onDidRemoveCapability: Event<TerminalCapabilityChangeEvent<any>>;\n\n\t/**\n\t * Gets whether the capability exists in the store.\n\t */\n\thas(capability: TerminalCapability): boolean;\n\n\t/**\n\t * Gets the implementation of a capability if it has been added to the store.\n\t */\n\tget<T extends TerminalCapability>(capability: T): ITerminalCapabilityImplMap[T] | undefined;\n}\n\nexport interface TerminalCapabilityChangeEvent<T extends TerminalCapability> {\n\tid: T;\n\tcapability: ITerminalCapabilityImplMap[T];\n}\n\n/**\n * Maps capability types to their implementation, enabling strongly typed fetching of\n * implementations.\n */\nexport interface ITerminalCapabilityImplMap {\n\t[TerminalCapability.CwdDetection]: ICwdDetectionCapability;\n\t[TerminalCapability.CommandDetection]: ICommandDetectionCapability;\n\t[TerminalCapability.NaiveCwdDetection]: INaiveCwdDetectionCapability;\n\t[TerminalCapability.PartialCommandDetection]: IPartialCommandDetectionCapability;\n\t[TerminalCapability.BufferMarkDetection]: IBufferMarkCapability;\n}\n\nexport interface ICwdDetectionCapability {\n\treadonly type: TerminalCapability.CwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\treadonly cwds: string[];\n\tgetCwd(): string;\n\tupdateCwd(cwd: string): void;\n}\n\nexport const enum CommandInvalidationReason {\n\tWindows = 'windows',\n\tNoProblemsReported = 'noProblemsReported'\n}\n\nexport interface ICommandInvalidationRequest {\n\treason: CommandInvalidationReason;\n}\n\nexport interface IBufferMarkCapability {\n\ttype: TerminalCapability.BufferMarkDetection;\n\tmarkers(): IterableIterator<IMarker>;\n\tonMarkAdded: Event<IMarkProperties>;\n\taddMark(properties?: IMarkProperties): void;\n\tgetMark(id: string): IMarker | undefined;\n}\n\nexport interface ICommandDetectionCapability {\n\treadonly type: TerminalCapability.CommandDetection;\n\treadonly commands: readonly ITerminalCommand[];\n\t/** The command currently being executed, otherwise undefined. */\n\treadonly executingCommand: string | undefined;\n\treadonly executingCommandObject: ITerminalCommand | undefined;\n\t/** The current cwd at the cursor's position. */\n\treadonly cwd: string | undefined;\n\t/**\n\t * Whether a command is currently being input. If the a command is current not being input or\n\t * the state cannot reliably be detected the fallback of undefined will be used.\n\t */\n\treadonly hasInput: boolean | undefined;\n\treadonly currentCommand: ICurrentPartialCommand | undefined;\n\treadonly onCommandStarted: Event<ITerminalCommand>;\n\treadonly onCommandFinished: Event<ITerminalCommand>;\n\treadonly onCommandExecuted: Event<void>;\n\treadonly onCommandInvalidated: Event<ITerminalCommand[]>;\n\treadonly onCurrentCommandInvalidated: Event<ICommandInvalidationRequest>;\n\tsetCwd(value: string): void;\n\tsetIsWindowsPty(value: boolean): void;\n\tsetIsCommandStorageDisabled(): void;\n\t/**\n\t * Gets the working directory for a line, this will return undefined if it's unknown in which\n\t * case the terminal's initial cwd should be used.\n\t */\n\tgetCwdForLine(line: number): string | undefined;\n\thandlePromptStart(options?: IHandleCommandOptions): void;\n\thandleContinuationStart(): void;\n\thandleContinuationEnd(): void;\n\thandleRightPromptStart(): void;\n\thandleRightPromptEnd(): void;\n\thandleCommandStart(options?: IHandleCommandOptions): void;\n\thandleCommandExecuted(options?: IHandleCommandOptions): void;\n\thandleCommandFinished(exitCode?: number, options?: IHandleCommandOptions): void;\n\tinvalidateCurrentCommand(request: ICommandInvalidationRequest): void;\n\t/**\n\t * Set the command line explicitly.\n\t * @param commandLine The command line being set.\n\t * @param isTrusted Whether the command line is trusted via the optional nonce is send in order\n\t * to prevent spoofing. This is important as some interactions do not require verification\n\t * before re-running a command. Note that this is optional according to the spec, it should\n\t * always be present when running the _builtin_ SI scripts.\n\t */\n\tsetCommandLine(commandLine: string, isTrusted: boolean): void;\n\tserialize(): ISerializedCommandDetectionCapability;\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void;\n}\n\nexport interface IHandleCommandOptions {\n\t/**\n\t * Whether to allow an empty command to be registered. This should be used to support certain\n\t * shell integration scripts/features where tracking the command line may not be possible.\n\t */\n\tignoreCommandLine?: boolean;\n\t/**\n\t * The marker to use\n\t */\n\tmarker?: IMarker;\n\n\t/**\n\t * Properties for the mark\n\t */\n\tmarkProperties?: IMarkProperties;\n}\n\nexport interface INaiveCwdDetectionCapability {\n\treadonly type: TerminalCapability.NaiveCwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\tgetCwd(): Promise<string>;\n}\n\nexport interface IPartialCommandDetectionCapability {\n\treadonly type: TerminalCapability.PartialCommandDetection;\n\treadonly commands: readonly IXtermMarker[];\n\treadonly onCommandFinished: Event<IXtermMarker>;\n}\n\ninterface IBaseTerminalCommand {\n\t// Mandatory\n\tcommand: string;\n\tisTrusted: boolean;\n\ttimestamp: number;\n\n\t// Optional serializable\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n}\n\nexport interface ITerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable\n\tmarker?: IXtermMarker;\n\tendMarker?: IXtermMarker;\n\texecutedMarker?: IXtermMarker;\n\taliases?: string[][];\n\twasReplayed?: boolean;\n\n\tgetOutput(): string | undefined;\n\tgetOutputMatch(outputMatcher: ITerminalOutputMatcher): ITerminalOutputMatch | undefined;\n\thasOutput(): boolean;\n}\n\nexport interface ISerializedTerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable converted for serialization\n\tstartLine: number | undefined;\n\tstartX: number | undefined;\n\tendLine: number | undefined;\n\texecutedLine: number | undefined;\n}\n\n/**\n * A clone of the IMarker from xterm which cannot be imported from common\n */\nexport interface IXtermMarker {\n\treadonly id: number;\n\treadonly isDisposed: boolean;\n\treadonly line: number;\n\tdispose(): void;\n\tonDispose: {\n\t\t(listener: () => any): { dispose(): void };\n\t};\n}\n\nexport interface IMarkProperties {\n\thoverMessage?: string;\n\tdisableCommandStorage?: boolean;\n\thidden?: boolean;\n\tmarker?: IMarker;\n\tid?: string;\n}\nexport interface ISerializedCommandDetectionCapability {\n\tisWindowsPty: boolean;\n\tcommands: ISerializedTerminalCommand[];\n}\nexport interface IPtyHostProcessReplayEvent {\n\tevents: ReplayEntry[];\n\tcommands: ISerializedCommandDetectionCapability;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { IDisposable } from 'vs/base/common/lifecycle';\nimport { ICurrentPartialCommand } from 'vs/platform/terminal/common/capabilities/commandDetectionCapability';\nimport { ITerminalOutputMatch, ITerminalOutputMatcher } from 'vs/platform/terminal/common/terminal';\nimport { ReplayEntry } from 'vs/platform/terminal/common/terminalProcess';\n\ninterface IEvent<T, U = void> {\n\t(listener: (arg1: T, arg2: U) => any): IDisposable;\n}\n\nexport interface IMarker extends IDisposable {\n\t/**\n\t * A unique identifier for this marker.\n\t */\n\treadonly id: number;\n\n\t/**\n\t * Whether this marker is disposed.\n\t */\n\treadonly isDisposed: boolean;\n\n\t/**\n\t * The actual line index in the buffer at this point in time. This is set to\n\t * -1 if the marker has been disposed.\n\t */\n\treadonly line: number;\n\n\t/**\n\t * Event listener to get notified when the marker gets disposed. Automatic disposal\n\t * might happen for a marker, that got invalidated by scrolling out or removal of\n\t * a line from the buffer.\n\t */\n\tonDispose: IEvent<void>;\n}\n\n\n/**\n * Primarily driven by the shell integration feature, a terminal capability is the mechanism for\n * progressively enhancing various features that may not be supported in all terminals/shells.\n */\nexport const enum TerminalCapability {\n\t/**\n\t * The terminal can reliably detect the current working directory as soon as the change happens\n\t * within the buffer.\n\t */\n\tCwdDetection,\n\t/**\n\t * The terminal can reliably detect the current working directory when requested.\n\t */\n\tNaiveCwdDetection,\n\t/**\n\t * The terminal can reliably identify prompts, commands and command outputs within the buffer.\n\t */\n\tCommandDetection,\n\t/**\n\t * The terminal can often identify prompts, commands and command outputs within the buffer. It\n\t * may not be so good at remembering the position of commands that ran in the past. This state\n\t * may be enabled when something goes wrong or when using conpty for example.\n\t */\n\tPartialCommandDetection,\n\n\t/**\n\t * Manages buffer marks that can be used for terminal navigation. The source of\n\t * the request (task, debug, etc) provides an ID, optional marker, hoverMessage, and hidden property. When\n\t * hidden is not provided, a generic decoration is added to the buffer and overview ruler.\n\t */\n\tBufferMarkDetection\n}\n\n/**\n * An object that keeps track of additional capabilities and their implementations for features that\n * are not available for all terminals.\n */\nexport interface ITerminalCapabilityStore {\n\t/**\n\t * An iterable of all capabilities in the store.\n\t */\n\treadonly items: IterableIterator<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is added. The event data for this is only the\n\t * {@link TerminalCapability} type, use {@link onDidAddCapability} to access the actual\n\t * capability.\n\t */\n\treadonly onDidAddCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is removed. The event data for this is only the\n\t * {@link TerminalCapability} type, use {@link onDidAddCapability} to access the actual\n\t * capability.\n\t */\n\treadonly onDidRemoveCapabilityType: Event<TerminalCapability>;\n\n\t/**\n\t * Fired when a capability is added.\n\t */\n\treadonly onDidAddCapability: Event<TerminalCapabilityChangeEvent<any>>;\n\n\t/**\n\t * Fired when a capability is removed.\n\t */\n\treadonly onDidRemoveCapability: Event<TerminalCapabilityChangeEvent<any>>;\n\n\t/**\n\t * Gets whether the capability exists in the store.\n\t */\n\thas(capability: TerminalCapability): boolean;\n\n\t/**\n\t * Gets the implementation of a capability if it has been added to the store.\n\t */\n\tget<T extends TerminalCapability>(capability: T): ITerminalCapabilityImplMap[T] | undefined;\n}\n\nexport interface TerminalCapabilityChangeEvent<T extends TerminalCapability> {\n\tid: T;\n\tcapability: ITerminalCapabilityImplMap[T];\n}\n\n/**\n * Maps capability types to their implementation, enabling strongly typed fetching of\n * implementations.\n */\nexport interface ITerminalCapabilityImplMap {\n\t[TerminalCapability.CwdDetection]: ICwdDetectionCapability;\n\t[TerminalCapability.CommandDetection]: ICommandDetectionCapability;\n\t[TerminalCapability.NaiveCwdDetection]: INaiveCwdDetectionCapability;\n\t[TerminalCapability.PartialCommandDetection]: IPartialCommandDetectionCapability;\n\t[TerminalCapability.BufferMarkDetection]: IBufferMarkCapability;\n}\n\nexport interface ICwdDetectionCapability {\n\treadonly type: TerminalCapability.CwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\treadonly cwds: string[];\n\tgetCwd(): string;\n\tupdateCwd(cwd: string): void;\n}\n\nexport const enum CommandInvalidationReason {\n\tWindows = 'windows',\n\tNoProblemsReported = 'noProblemsReported'\n}\n\nexport interface ICommandInvalidationRequest {\n\treason: CommandInvalidationReason;\n}\n\nexport interface IBufferMarkCapability {\n\ttype: TerminalCapability.BufferMarkDetection;\n\tmarkers(): IterableIterator<IMarker>;\n\tonMarkAdded: Event<IMarkProperties>;\n\taddMark(properties?: IMarkProperties): void;\n\tgetMark(id: string): IMarker | undefined;\n}\n\nexport interface ICommandDetectionCapability {\n\treadonly type: TerminalCapability.CommandDetection;\n\treadonly commands: readonly ITerminalCommand[];\n\t/** The command currently being executed, otherwise undefined. */\n\treadonly executingCommand: string | undefined;\n\treadonly executingCommandObject: ITerminalCommand | undefined;\n\t/** The current cwd at the cursor's position. */\n\treadonly cwd: string | undefined;\n\t/**\n\t * Whether a command is currently being input. If the a command is current not being input or\n\t * the state cannot reliably be detected the fallback of undefined will be used.\n\t */\n\treadonly hasInput: boolean | undefined;\n\treadonly currentCommand: ICurrentPartialCommand | undefined;\n\treadonly onCommandStarted: Event<ITerminalCommand>;\n\treadonly onCommandFinished: Event<ITerminalCommand>;\n\treadonly onCommandExecuted: Event<void>;\n\treadonly onCommandInvalidated: Event<ITerminalCommand[]>;\n\treadonly onCurrentCommandInvalidated: Event<ICommandInvalidationRequest>;\n\tsetCwd(value: string): void;\n\tsetIsWindowsPty(value: boolean): void;\n\tsetIsCommandStorageDisabled(): void;\n\t/**\n\t * Gets the working directory for a line, this will return undefined if it's unknown in which\n\t * case the terminal's initial cwd should be used.\n\t */\n\tgetCwdForLine(line: number): string | undefined;\n\thandlePromptStart(options?: IHandleCommandOptions): void;\n\thandleContinuationStart(): void;\n\thandleContinuationEnd(): void;\n\thandleRightPromptStart(): void;\n\thandleRightPromptEnd(): void;\n\thandleCommandStart(options?: IHandleCommandOptions): void;\n\thandleCommandExecuted(options?: IHandleCommandOptions): void;\n\thandleCommandFinished(exitCode?: number, options?: IHandleCommandOptions): void;\n\tinvalidateCurrentCommand(request: ICommandInvalidationRequest): void;\n\t/**\n\t * Set the command line explicitly.\n\t * @param commandLine The command line being set.\n\t * @param isTrusted Whether the command line is trusted via the optional nonce is send in order\n\t * to prevent spoofing. This is important as some interactions do not require verification\n\t * before re-running a command. Note that this is optional according to the spec, it should\n\t * always be present when running the _builtin_ SI scripts.\n\t */\n\tsetCommandLine(commandLine: string, isTrusted: boolean): void;\n\tserialize(): ISerializedCommandDetectionCapability;\n\tdeserialize(serialized: ISerializedCommandDetectionCapability): void;\n}\n\nexport interface IHandleCommandOptions {\n\t/**\n\t * Whether to allow an empty command to be registered. This should be used to support certain\n\t * shell integration scripts/features where tracking the command line may not be possible.\n\t */\n\tignoreCommandLine?: boolean;\n\t/**\n\t * The marker to use\n\t */\n\tmarker?: IMarker;\n\n\t/**\n\t * Properties for the mark\n\t */\n\tmarkProperties?: IMarkProperties;\n}\n\nexport interface INaiveCwdDetectionCapability {\n\treadonly type: TerminalCapability.NaiveCwdDetection;\n\treadonly onDidChangeCwd: Event<string>;\n\tgetCwd(): Promise<string>;\n}\n\nexport interface IPartialCommandDetectionCapability {\n\treadonly type: TerminalCapability.PartialCommandDetection;\n\treadonly commands: readonly IXtermMarker[];\n\treadonly onCommandFinished: Event<IXtermMarker>;\n}\n\ninterface IBaseTerminalCommand {\n\t// Mandatory\n\tcommand: string;\n\tisTrusted: boolean;\n\ttimestamp: number;\n\n\t// Optional serializable\n\tcwd: string | undefined;\n\texitCode: number | undefined;\n\tcommandStartLineContent: string | undefined;\n\tmarkProperties: IMarkProperties | undefined;\n}\n\nexport interface ITerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable\n\tmarker?: IXtermMarker;\n\tendMarker?: IXtermMarker;\n\texecutedMarker?: IXtermMarker;\n\taliases?: string[][];\n\twasReplayed?: boolean;\n\n\tgetOutput(): string | undefined;\n\tgetOutputMatch(outputMatcher: ITerminalOutputMatcher): ITerminalOutputMatch | undefined;\n\thasOutput(): boolean;\n}\n\nexport interface ISerializedTerminalCommand extends IBaseTerminalCommand {\n\t// Optional non-serializable converted for serialization\n\tstartLine: number | undefined;\n\tstartX: number | undefined;\n\tendLine: number | undefined;\n\texecutedLine: number | undefined;\n}\n\n/**\n * A clone of the IMarker from xterm which cannot be imported from common\n */\nexport interface IXtermMarker {\n\treadonly id: number;\n\treadonly isDisposed: boolean;\n\treadonly line: number;\n\tdispose(): void;\n\tonDispose: {\n\t\t(listener: () => any): { dispose(): void };\n\t};\n}\n\nexport interface IMarkProperties {\n\thoverMessage?: string;\n\tdisableCommandStorage?: boolean;\n\thidden?: boolean;\n\tmarker?: IMarker;\n\tid?: string;\n}\nexport interface ISerializedCommandDetectionCapability {\n\tisWindowsPty: boolean;\n\tcommands: ISerializedTerminalCommand[];\n}\nexport interface IPtyHostProcessReplayEvent {\n\tevents: ReplayEntry[];\n\tcommands: ISerializedCommandDetectionCapability;\n}\n"]}