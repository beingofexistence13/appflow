{"version":3,"sources":["vs/base/node/zip.ts"],"names":[],"mappings":"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","file":"zip.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { createWriteStream, WriteStream } from 'fs';\nimport { Readable } from 'stream';\nimport { createCancelablePromise, Sequencer } from 'vs/base/common/async';\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport * as path from 'vs/base/common/path';\nimport { assertIsDefined } from 'vs/base/common/types';\nimport { Promises } from 'vs/base/node/pfs';\nimport * as nls from 'vs/nls';\nimport { Entry, open as _openZip, ZipFile } from 'yauzl';\nimport * as yazl from 'yazl';\n\nexport const CorruptZipMessage: string = 'end of central directory record signature not found';\nconst CORRUPT_ZIP_PATTERN = new RegExp(CorruptZipMessage);\n\nexport interface IExtractOptions {\n\toverwrite?: boolean;\n\n\t/**\n\t * Source path within the ZIP archive. Only the files contained in this\n\t * path will be extracted.\n\t */\n\tsourcePath?: string;\n}\n\ninterface IOptions {\n\tsourcePathRegex: RegExp;\n}\n\nexport type ExtractErrorType = 'CorruptZip' | 'Incomplete';\n\nexport class ExtractError extends Error {\n\n\treadonly type?: ExtractErrorType;\n\n\tconstructor(type: ExtractErrorType | undefined, cause: Error) {\n\t\tlet message = cause.message;\n\n\t\tswitch (type) {\n\t\t\tcase 'CorruptZip': message = `Corrupt ZIP: ${message}`; break;\n\t\t}\n\n\t\tsuper(message);\n\t\tthis.type = type;\n\t\tthis.cause = cause;\n\t}\n}\n\nfunction modeFromEntry(entry: Entry) {\n\tconst attr = entry.externalFileAttributes >> 16 || 33188;\n\n\treturn [448 /* S_IRWXU */, 56 /* S_IRWXG */, 7 /* S_IRWXO */]\n\t\t.map(mask => attr & mask)\n\t\t.reduce((a, b) => a + b, attr & 61440 /* S_IFMT */);\n}\n\nfunction toExtractError(err: Error): ExtractError {\n\tif (err instanceof ExtractError) {\n\t\treturn err;\n\t}\n\n\tlet type: ExtractErrorType | undefined = undefined;\n\n\tif (CORRUPT_ZIP_PATTERN.test(err.message)) {\n\t\ttype = 'CorruptZip';\n\t}\n\n\treturn new ExtractError(type, err);\n}\n\nfunction extractEntry(stream: Readable, fileName: string, mode: number, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tconst dirName = path.dirname(fileName);\n\tconst targetDirName = path.join(targetPath, dirName);\n\tif (!targetDirName.startsWith(targetPath)) {\n\t\treturn Promise.reject(new Error(nls.localize('invalid file', \"Error extracting {0}. Invalid file.\", fileName)));\n\t}\n\tconst targetFileName = path.join(targetPath, fileName);\n\n\tlet istream: WriteStream;\n\n\ttoken.onCancellationRequested(() => {\n\t\tistream?.destroy();\n\t});\n\n\treturn Promise.resolve(Promises.mkdir(targetDirName, { recursive: true })).then(() => new Promise<void>((c, e) => {\n\t\tif (token.isCancellationRequested) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tistream = createWriteStream(targetFileName, { mode });\n\t\t\tistream.once('close', () => c());\n\t\t\tistream.once('error', e);\n\t\t\tstream.once('error', e);\n\t\t\tstream.pipe(istream);\n\t\t} catch (error) {\n\t\t\te(error);\n\t\t}\n\t}));\n}\n\nfunction extractZip(zipfile: ZipFile, targetPath: string, options: IOptions, token: CancellationToken): Promise<void> {\n\tlet last = createCancelablePromise<void>(() => Promise.resolve());\n\tlet extractedEntriesCount = 0;\n\n\tconst listener = token.onCancellationRequested(() => {\n\t\tlast.cancel();\n\t\tzipfile.close();\n\t});\n\n\treturn new Promise<void>((c, e) => {\n\t\tconst throttler = new Sequencer();\n\n\t\tconst readNextEntry = (token: CancellationToken) => {\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\textractedEntriesCount++;\n\t\t\tzipfile.readEntry();\n\t\t};\n\n\t\tzipfile.once('error', e);\n\t\tzipfile.once('close', () => last.then(() => {\n\t\t\tif (token.isCancellationRequested || zipfile.entryCount === extractedEntriesCount) {\n\t\t\t\tc();\n\t\t\t} else {\n\t\t\t\te(new ExtractError('Incomplete', new Error(nls.localize('incompleteExtract', \"Incomplete. Found {0} of {1} entries\", extractedEntriesCount, zipfile.entryCount))));\n\t\t\t}\n\t\t}, e));\n\t\tzipfile.readEntry();\n\t\tzipfile.on('entry', (entry: Entry) => {\n\n\t\t\tif (token.isCancellationRequested) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!options.sourcePathRegex.test(entry.fileName)) {\n\t\t\t\treadNextEntry(token);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst fileName = entry.fileName.replace(options.sourcePathRegex, '');\n\n\t\t\t// directory file names end with '/'\n\t\t\tif (/\\/$/.test(fileName)) {\n\t\t\t\tconst targetFileName = path.join(targetPath, fileName);\n\t\t\t\tlast = createCancelablePromise(token => Promises.mkdir(targetFileName, { recursive: true }).then(() => readNextEntry(token)).then(undefined, e));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst stream = openZipStream(zipfile, entry);\n\t\t\tconst mode = modeFromEntry(entry);\n\n\t\t\tlast = createCancelablePromise(token => throttler.queue(() => stream.then(stream => extractEntry(stream, fileName, mode, targetPath, options, token).then(() => readNextEntry(token)))).then(null, e));\n\t\t});\n\t}).finally(() => listener.dispose());\n}\n\nfunction openZip(zipFile: string, lazy: boolean = false): Promise<ZipFile> {\n\treturn new Promise<ZipFile>((resolve, reject) => {\n\t\t_openZip(zipFile, lazy ? { lazyEntries: true } : undefined!, (error?: Error, zipfile?: ZipFile) => {\n\t\t\tif (error) {\n\t\t\t\treject(toExtractError(error));\n\t\t\t} else {\n\t\t\t\tresolve(assertIsDefined(zipfile));\n\t\t\t}\n\t\t});\n\t});\n}\n\nfunction openZipStream(zipFile: ZipFile, entry: Entry): Promise<Readable> {\n\treturn new Promise<Readable>((resolve, reject) => {\n\t\tzipFile.openReadStream(entry, (error?: Error, stream?: Readable) => {\n\t\t\tif (error) {\n\t\t\t\treject(toExtractError(error));\n\t\t\t} else {\n\t\t\t\tresolve(assertIsDefined(stream));\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IFile {\n\tpath: string;\n\tcontents?: Buffer | string;\n\tlocalPath?: string;\n}\n\nexport function zip(zipPath: string, files: IFile[]): Promise<string> {\n\treturn new Promise<string>((c, e) => {\n\t\tconst zip = new yazl.ZipFile();\n\t\tfiles.forEach(f => {\n\t\t\tif (f.contents) {\n\t\t\t\tzip.addBuffer(typeof f.contents === 'string' ? Buffer.from(f.contents, 'utf8') : f.contents, f.path);\n\t\t\t} else if (f.localPath) {\n\t\t\t\tzip.addFile(f.localPath, f.path);\n\t\t\t}\n\t\t});\n\t\tzip.end();\n\n\t\tconst zipStream = createWriteStream(zipPath);\n\t\tzip.outputStream.pipe(zipStream);\n\n\t\tzip.outputStream.once('error', e);\n\t\tzipStream.once('error', e);\n\t\tzipStream.once('finish', () => c(zipPath));\n\t});\n}\n\nexport function extract(zipPath: string, targetPath: string, options: IExtractOptions = {}, token: CancellationToken): Promise<void> {\n\tconst sourcePathRegex = new RegExp(options.sourcePath ? `^${options.sourcePath}` : '');\n\n\tlet promise = openZip(zipPath, true);\n\n\tif (options.overwrite) {\n\t\tpromise = promise.then(zipfile => Promises.rm(targetPath).then(() => zipfile));\n\t}\n\n\treturn promise.then(zipfile => extractZip(zipfile, targetPath, { sourcePathRegex }, token));\n}\n\nfunction read(zipPath: string, filePath: string): Promise<Readable> {\n\treturn openZip(zipPath).then(zipfile => {\n\t\treturn new Promise<Readable>((c, e) => {\n\t\t\tzipfile.on('entry', (entry: Entry) => {\n\t\t\t\tif (entry.fileName === filePath) {\n\t\t\t\t\topenZipStream(zipfile, entry).then(stream => c(stream), err => e(err));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tzipfile.once('close', () => e(new Error(nls.localize('notFound', \"{0} not found inside zip.\", filePath))));\n\t\t});\n\t});\n}\n\nexport function buffer(zipPath: string, filePath: string): Promise<Buffer> {\n\treturn read(zipPath, filePath).then(stream => {\n\t\treturn new Promise<Buffer>((c, e) => {\n\t\t\tconst buffers: Buffer[] = [];\n\t\t\tstream.once('error', e);\n\t\t\tstream.on('data', (b: Buffer) => buffers.push(b));\n\t\t\tstream.on('end', () => c(Buffer.concat(buffers)));\n\t\t});\n\t});\n}\n"]}