{"version":3,"sources":["vs/workbench/contrib/testing/common/testResult.ts"],"names":[],"mappings":"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","file":"testResult.js","sourceRoot":"file:///workspace/appflow/src","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DeferredPromise } from 'vs/base/common/async';\nimport { VSBuffer } from 'vs/base/common/buffer';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Lazy } from 'vs/base/common/lazy';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { language } from 'vs/base/common/platform';\nimport { WellDefinedPrefixTree } from 'vs/base/common/prefixTree';\nimport { removeAnsiEscapeCodes } from 'vs/base/common/strings';\nimport { localize } from 'vs/nls';\nimport { IComputedStateAccessor, refreshComputedState } from 'vs/workbench/contrib/testing/common/getComputedState';\nimport { IObservableValue, MutableObservableValue, staticObservableValue } from 'vs/workbench/contrib/testing/common/observableValue';\nimport { TestCoverage } from 'vs/workbench/contrib/testing/common/testCoverage';\nimport { TestId } from 'vs/workbench/contrib/testing/common/testId';\nimport { makeEmptyCounts, maxPriority, statesInOrder, terminalStatePriorities, TestStateCount } from 'vs/workbench/contrib/testing/common/testingStates';\nimport { getMarkId, IRichLocation, ISerializedTestResults, ITestItem, ITestMessage, ITestOutputMessage, ITestRunTask, ITestTaskState, ResolvedTestRunRequest, TestItemExpandState, TestMessageType, TestResultItem, TestResultState } from 'vs/workbench/contrib/testing/common/testTypes';\n\nexport interface ITestRunTaskResults extends ITestRunTask {\n\t/**\n\t * Contains test coverage for the result, if it's available.\n\t */\n\treadonly coverage: IObservableValue<TestCoverage | undefined>;\n\n\t/**\n\t * Messages from the task not associated with any specific test.\n\t */\n\treadonly otherMessages: ITestOutputMessage[];\n\n\t/**\n\t * Test results output for the task.\n\t */\n\treadonly output: ITaskRawOutput;\n}\n\nexport interface ITestResult {\n\t/**\n\t * Count of the number of tests in each run state.\n\t */\n\treadonly counts: Readonly<TestStateCount>;\n\n\t/**\n\t * Unique ID of this set of test results.\n\t */\n\treadonly id: string;\n\n\t/**\n\t * If the test is completed, the unix milliseconds time at which it was\n\t * completed. If undefined, the test is still running.\n\t */\n\treadonly completedAt: number | undefined;\n\n\t/**\n\t * Whether this test result is triggered from an auto run.\n\t */\n\treadonly request: ResolvedTestRunRequest;\n\n\t/**\n\t * Human-readable name of the test result.\n\t */\n\treadonly name: string;\n\n\t/**\n\t * Gets all tests involved in the run.\n\t */\n\ttests: IterableIterator<TestResultItem>;\n\n\t/**\n\t * List of this result's subtasks.\n\t */\n\ttasks: ReadonlyArray<ITestRunTaskResults>;\n\n\t/**\n\t * Gets the state of the test by its extension-assigned ID.\n\t */\n\tgetStateById(testExtId: string): TestResultItem | undefined;\n\n\t/**\n\t * Serializes the test result. Used to save and restore results\n\t * in the workspace.\n\t */\n\ttoJSON(): ISerializedTestResults | undefined;\n\n\t/**\n\t * Serializes the test result, includes messages. Used to send the test states to the extension host.\n\t */\n\ttoJSONWithMessages(): ISerializedTestResults | undefined;\n}\n\n/**\n * Output type exposed from live test results.\n */\nexport interface ITaskRawOutput {\n\treadonly onDidWriteData: Event<VSBuffer>;\n\treadonly endPromise: Promise<void>;\n\treadonly buffers: VSBuffer[];\n\treadonly length: number;\n\n\t/** Gets a continuous buffer for the desired range */\n\tgetRange(start: number, length: number): VSBuffer;\n\t/** Gets an iterator of buffers for the range; may avoid allocation of getRange() */\n\tgetRangeIter(start: number, length: number): Iterable<VSBuffer>;\n}\n\nconst emptyRawOutput: ITaskRawOutput = {\n\tbuffers: [],\n\tlength: 0,\n\tonDidWriteData: Event.None,\n\tendPromise: Promise.resolve(),\n\tgetRange: () => VSBuffer.alloc(0),\n\tgetRangeIter: () => [],\n};\n\nexport class TaskRawOutput implements ITaskRawOutput {\n\tprivate readonly writeDataEmitter = new Emitter<VSBuffer>();\n\tprivate readonly endDeferred = new DeferredPromise<void>();\n\tprivate offset = 0;\n\n\t/** @inheritdoc */\n\tpublic readonly onDidWriteData = this.writeDataEmitter.event;\n\n\t/** @inheritdoc */\n\tpublic readonly endPromise = this.endDeferred.p;\n\n\t/** @inheritdoc */\n\tpublic readonly buffers: VSBuffer[] = [];\n\n\t/** @inheritdoc */\n\tpublic get length() {\n\t\treturn this.offset;\n\t}\n\n\t/** @inheritdoc */\n\tgetRange(start: number, length: number): VSBuffer {\n\t\tconst buf = VSBuffer.alloc(length);\n\t\tlet bufLastWrite = 0;\n\t\tfor (const chunk of this.getRangeIter(start, length)) {\n\t\t\tbuf.buffer.set(chunk.buffer, bufLastWrite);\n\t\t\tbufLastWrite += chunk.byteLength;\n\t\t}\n\n\t\treturn bufLastWrite < length ? buf.slice(0, bufLastWrite) : buf;\n\t}\n\n\t/** @inheritdoc */\n\t*getRangeIter(start: number, length: number) {\n\t\tlet soFar = 0;\n\t\tlet internalLastRead = 0;\n\t\tfor (const b of this.buffers) {\n\t\t\tif (internalLastRead + b.byteLength <= start) {\n\t\t\t\tinternalLastRead += b.byteLength;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst bstart = Math.max(0, start - internalLastRead);\n\t\t\tconst bend = Math.min(b.byteLength, bstart + length - soFar);\n\n\t\t\tyield b.slice(bstart, bend);\n\t\t\tsoFar += bend - bstart;\n\t\t\tinternalLastRead += b.byteLength;\n\n\t\t\tif (soFar === length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Appends data to the output, returning the byte range where the data can be found.\n\t */\n\tpublic append(data: VSBuffer, marker?: number) {\n\t\tconst offset = this.offset;\n\t\tlet length = data.byteLength;\n\t\tif (marker === undefined) {\n\t\t\tthis.push(data);\n\t\t\treturn { offset, length };\n\t\t}\n\n\t\t// Bytes that should be 'trimmed' off the end of data. This is done because\n\t\t// selections in the terminal are based on the entire line, and commonly\n\t\t// the interesting marked range has a trailing new line. We don't want to\n\t\t// select the trailing line (which might have other data)\n\t\t// so we place the marker before all trailing trimbytes.\n\t\tconst enum TrimBytes {\n\t\t\tCR = 13,\n\t\t\tLF = 10,\n\t\t}\n\n\t\tconst start = VSBuffer.fromString(getMarkCode(marker, true));\n\t\tconst end = VSBuffer.fromString(getMarkCode(marker, false));\n\t\tlength += start.byteLength + end.byteLength;\n\n\t\tthis.push(start);\n\t\tlet trimLen = data.byteLength;\n\t\tfor (; trimLen > 0; trimLen--) {\n\t\t\tconst last = data.buffer[trimLen - 1];\n\t\t\tif (last !== TrimBytes.CR && last !== TrimBytes.LF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.push(data.slice(0, trimLen));\n\t\tthis.push(end);\n\t\tthis.push(data.slice(trimLen));\n\n\n\t\treturn { offset, length };\n\t}\n\n\tprivate push(data: VSBuffer) {\n\t\tif (data.byteLength === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.buffers.push(data);\n\t\tthis.writeDataEmitter.fire(data);\n\t\tthis.offset += data.byteLength;\n\t}\n\n\t/** Signals the output has ended. */\n\tpublic end() {\n\t\tthis.endDeferred.complete();\n\t}\n}\n\nexport const resultItemParents = function* (results: ITestResult, item: TestResultItem) {\n\tfor (const id of TestId.fromString(item.item.extId).idsToRoot()) {\n\t\tyield results.getStateById(id.toString())!;\n\t}\n};\n\nexport const maxCountPriority = (counts: Readonly<TestStateCount>) => {\n\tfor (const state of statesInOrder) {\n\t\tif (counts[state] > 0) {\n\t\t\treturn state;\n\t\t}\n\t}\n\n\treturn TestResultState.Unset;\n};\n\nconst getMarkCode = (marker: number, start: boolean) => `\\x1b]633;SetMark;Id=${getMarkId(marker, start)};Hidden\\x07`;\n\ninterface TestResultItemWithChildren extends TestResultItem {\n\t/** Children in the run */\n\tchildren: TestResultItemWithChildren[];\n}\n\nconst itemToNode = (controllerId: string, item: ITestItem, parent: string | null): TestResultItemWithChildren => ({\n\tcontrollerId,\n\texpand: TestItemExpandState.NotExpandable,\n\titem: { ...item },\n\tchildren: [],\n\ttasks: [],\n\townComputedState: TestResultState.Unset,\n\tcomputedState: TestResultState.Unset,\n});\n\nexport const enum TestResultItemChangeReason {\n\tComputedStateChange,\n\tOwnStateChange,\n\tNewMessage,\n}\n\nexport type TestResultItemChange = { item: TestResultItem; result: ITestResult } & (\n\t| { reason: TestResultItemChangeReason.ComputedStateChange }\n\t| { reason: TestResultItemChangeReason.OwnStateChange; previousState: TestResultState; previousOwnDuration: number | undefined }\n\t| { reason: TestResultItemChangeReason.NewMessage; message: ITestMessage }\n);\n\n/**\n * Results of a test. These are created when the test initially started running\n * and marked as \"complete\" when the run finishes.\n */\nexport class LiveTestResult extends Disposable implements ITestResult {\n\tprivate readonly completeEmitter = this._register(new Emitter<void>());\n\tprivate readonly newTaskEmitter = this._register(new Emitter<number>());\n\tprivate readonly endTaskEmitter = this._register(new Emitter<number>());\n\tprivate readonly changeEmitter = this._register(new Emitter<TestResultItemChange>());\n\t/** todo@connor4312: convert to a WellDefinedPrefixTree */\n\tprivate readonly testById = new Map<string, TestResultItemWithChildren>();\n\tprivate testMarkerCounter = 0;\n\tprivate _completedAt?: number;\n\n\tpublic readonly startedAt = Date.now();\n\tpublic readonly onChange = this.changeEmitter.event;\n\tpublic readonly onComplete = this.completeEmitter.event;\n\tpublic readonly onNewTask = this.newTaskEmitter.event;\n\tpublic readonly onEndTask = this.endTaskEmitter.event;\n\tpublic readonly tasks: (ITestRunTaskResults & { output: TaskRawOutput })[] = [];\n\tpublic readonly name = localize('runFinished', 'Test run at {0}', new Date().toLocaleString(language));\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get completedAt() {\n\t\treturn this._completedAt;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly counts = makeEmptyCounts();\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get tests() {\n\t\treturn this.testById.values();\n\t}\n\n\tprivate readonly computedStateAccessor: IComputedStateAccessor<TestResultItemWithChildren> = {\n\t\tgetOwnState: i => i.ownComputedState,\n\t\tgetCurrentComputedState: i => i.computedState,\n\t\tsetComputedState: (i, s) => i.computedState = s,\n\t\tgetChildren: i => i.children,\n\t\tgetParents: i => {\n\t\t\tconst { testById: testByExtId } = this;\n\t\t\treturn (function* () {\n\t\t\t\tconst parentId = TestId.fromString(i.item.extId).parentId;\n\t\t\t\tif (parentId) {\n\t\t\t\t\tfor (const id of parentId.idsToRoot()) {\n\t\t\t\t\t\tyield testByExtId.get(id.toString())!;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t},\n\t};\n\n\tconstructor(\n\t\tpublic readonly id: string,\n\t\tpublic readonly persist: boolean,\n\t\tpublic readonly request: ResolvedTestRunRequest,\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getStateById(extTestId: string) {\n\t\treturn this.testById.get(extTestId);\n\t}\n\n\t/**\n\t * Appends output that occurred during the test run.\n\t */\n\tpublic appendOutput(output: VSBuffer, taskId: string, location?: IRichLocation, testId?: string): void {\n\t\tconst preview = output.byteLength > 100 ? output.slice(0, 100).toString() + 'â€¦' : output.toString();\n\t\tlet marker: number | undefined;\n\n\t\t// currently, the UI only exposes jump-to-message from tests or locations,\n\t\t// so no need to mark outputs that don't come from either of those.\n\t\tif (testId || location) {\n\t\t\tmarker = this.testMarkerCounter++;\n\t\t}\n\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tconst task = this.tasks[index];\n\n\t\tconst { offset, length } = task.output.append(output, marker);\n\t\tconst message: ITestOutputMessage = {\n\t\t\tlocation,\n\t\t\tmessage: removeAnsiEscapeCodes(preview),\n\t\t\toffset,\n\t\t\tlength,\n\t\t\tmarker,\n\t\t\ttype: TestMessageType.Output,\n\t\t};\n\n\t\tconst test = testId && this.testById.get(testId);\n\t\tif (test) {\n\t\t\ttest.tasks[index].messages.push(message);\n\t\t\tthis.changeEmitter.fire({ item: test, result: this, reason: TestResultItemChangeReason.NewMessage, message });\n\t\t} else {\n\t\t\ttask.otherMessages.push(message);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new run task to the results.\n\t */\n\tpublic addTask(task: ITestRunTask) {\n\t\tthis.tasks.push({ ...task, coverage: this._register(new MutableObservableValue(undefined)), otherMessages: [], output: new TaskRawOutput() });\n\n\t\tfor (const test of this.tests) {\n\t\t\ttest.tasks.push({ duration: undefined, messages: [], state: TestResultState.Unset });\n\t\t}\n\n\t\tthis.newTaskEmitter.fire(this.tasks.length - 1);\n\t}\n\n\t/**\n\t * Add the chain of tests to the run. The first test in the chain should\n\t * be either a test root, or a previously-known test.\n\t */\n\tpublic addTestChainToRun(controllerId: string, chain: ReadonlyArray<ITestItem>) {\n\t\tlet parent = this.testById.get(chain[0].extId);\n\t\tif (!parent) { // must be a test root\n\t\t\tparent = this.addTestToRun(controllerId, chain[0], null);\n\t\t}\n\n\t\tfor (let i = 1; i < chain.length; i++) {\n\t\t\tparent = this.addTestToRun(controllerId, chain[i], parent.item.extId);\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Updates the state of the test by its internal ID.\n\t */\n\tpublic updateState(testId: string, taskId: string, state: TestResultState, duration?: number) {\n\t\tconst entry = this.testById.get(testId);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\n\t\tconst oldTerminalStatePrio = terminalStatePriorities[entry.tasks[index].state];\n\t\tconst newTerminalStatePrio = terminalStatePriorities[state];\n\n\t\t// Ignore requests to set the state from one terminal state back to a\n\t\t// \"lower\" one, e.g. from failed back to passed:\n\t\tif (oldTerminalStatePrio !== undefined &&\n\t\t\t(newTerminalStatePrio === undefined || newTerminalStatePrio < oldTerminalStatePrio)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.fireUpdateAndRefresh(entry, index, state, duration);\n\t}\n\n\t/**\n\t * Appends a message for the test in the run.\n\t */\n\tpublic appendMessage(testId: string, taskId: string, message: ITestMessage) {\n\t\tconst entry = this.testById.get(testId);\n\t\tif (!entry) {\n\t\t\treturn;\n\t\t}\n\n\t\tentry.tasks[this.mustGetTaskIndex(taskId)].messages.push(message);\n\t\tthis.changeEmitter.fire({ item: entry, result: this, reason: TestResultItemChangeReason.NewMessage, message });\n\t}\n\n\t/**\n\t * Marks the task in the test run complete.\n\t */\n\tpublic markTaskComplete(taskId: string) {\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tconst task = this.tasks[index];\n\t\ttask.running = false;\n\t\ttask.output.end();\n\n\t\tthis.setAllToState(\n\t\t\tTestResultState.Unset,\n\t\t\ttaskId,\n\t\t\tt => t.state === TestResultState.Queued || t.state === TestResultState.Running,\n\t\t);\n\n\t\tthis.endTaskEmitter.fire(index);\n\t}\n\n\t/**\n\t * Notifies the service that all tests are complete.\n\t */\n\tpublic markComplete() {\n\t\tif (this._completedAt !== undefined) {\n\t\t\tthrow new Error('cannot complete a test result multiple times');\n\t\t}\n\n\t\tfor (const task of this.tasks) {\n\t\t\tif (task.running) {\n\t\t\t\tthis.markTaskComplete(task.id);\n\t\t\t}\n\t\t}\n\n\t\tthis._completedAt = Date.now();\n\t\tthis.completeEmitter.fire();\n\t}\n\n\t/**\n\t * Marks the test and all of its children in the run as retired.\n\t */\n\tpublic markRetired(testIds: WellDefinedPrefixTree<undefined> | undefined) {\n\t\tfor (const [id, test] of this.testById) {\n\t\t\tif (!test.retired && (!testIds || testIds.hasKeyOrParent(TestId.fromString(id).path))) {\n\t\t\t\ttest.retired = true;\n\t\t\t\tthis.changeEmitter.fire({ reason: TestResultItemChangeReason.ComputedStateChange, item: test, result: this });\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSON(): ISerializedTestResults | undefined {\n\t\treturn this.completedAt && this.persist ? this.doSerialize.value : undefined;\n\t}\n\n\tpublic toJSONWithMessages(): ISerializedTestResults | undefined {\n\t\treturn this.completedAt && this.persist ? this.doSerializeWithMessages.value : undefined;\n\t}\n\n\t/**\n\t * Updates all tests in the collection to the given state.\n\t */\n\tprotected setAllToState(state: TestResultState, taskId: string, when: (task: ITestTaskState, item: TestResultItem) => boolean) {\n\t\tconst index = this.mustGetTaskIndex(taskId);\n\t\tfor (const test of this.testById.values()) {\n\t\t\tif (when(test.tasks[index], test)) {\n\t\t\t\tthis.fireUpdateAndRefresh(test, index, state);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fireUpdateAndRefresh(entry: TestResultItem, taskIndex: number, newState: TestResultState, newOwnDuration?: number) {\n\t\tconst previousOwnComputed = entry.ownComputedState;\n\t\tconst previousOwnDuration = entry.ownDuration;\n\t\tconst changeEvent: TestResultItemChange = {\n\t\t\titem: entry,\n\t\t\tresult: this,\n\t\t\treason: TestResultItemChangeReason.OwnStateChange,\n\t\t\tpreviousState: previousOwnComputed,\n\t\t\tpreviousOwnDuration: previousOwnDuration,\n\t\t};\n\n\t\tentry.tasks[taskIndex].state = newState;\n\t\tif (newOwnDuration !== undefined) {\n\t\t\tentry.tasks[taskIndex].duration = newOwnDuration;\n\t\t\tentry.ownDuration = Math.max(entry.ownDuration || 0, newOwnDuration);\n\t\t}\n\n\t\tconst newOwnComputed = maxPriority(...entry.tasks.map(t => t.state));\n\t\tif (newOwnComputed === previousOwnComputed) {\n\t\t\tif (newOwnDuration !== previousOwnDuration) {\n\t\t\t\tthis.changeEmitter.fire(changeEvent); // fire manually since state change won't do it\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tentry.ownComputedState = newOwnComputed;\n\t\tthis.counts[previousOwnComputed]--;\n\t\tthis.counts[newOwnComputed]++;\n\t\trefreshComputedState(this.computedStateAccessor, entry).forEach(t =>\n\t\t\tthis.changeEmitter.fire(t === entry ? changeEvent : {\n\t\t\t\titem: t,\n\t\t\t\tresult: this,\n\t\t\t\treason: TestResultItemChangeReason.ComputedStateChange,\n\t\t\t}),\n\t\t);\n\t}\n\n\tprivate addTestToRun(controllerId: string, item: ITestItem, parent: string | null) {\n\t\tconst node = itemToNode(controllerId, item, parent);\n\t\tthis.testById.set(item.extId, node);\n\t\tthis.counts[TestResultState.Unset]++;\n\n\t\tif (parent) {\n\t\t\tthis.testById.get(parent)?.children.push(node);\n\t\t}\n\n\t\tif (this.tasks.length) {\n\t\t\tfor (let i = 0; i < this.tasks.length; i++) {\n\t\t\t\tnode.tasks.push({ duration: undefined, messages: [], state: TestResultState.Unset });\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tprivate mustGetTaskIndex(taskId: string) {\n\t\tconst index = this.tasks.findIndex(t => t.id === taskId);\n\t\tif (index === -1) {\n\t\t\tthrow new Error(`Unknown task ${taskId} in updateState`);\n\t\t}\n\n\t\treturn index;\n\t}\n\n\tprivate readonly doSerialize = new Lazy((): ISerializedTestResults => ({\n\t\tid: this.id,\n\t\tcompletedAt: this.completedAt!,\n\t\ttasks: this.tasks.map(t => ({ id: t.id, name: t.name })),\n\t\tname: this.name,\n\t\trequest: this.request,\n\t\titems: [...this.testById.values()].map(TestResultItem.serializeWithoutMessages),\n\t}));\n\n\tprivate readonly doSerializeWithMessages = new Lazy((): ISerializedTestResults => ({\n\t\tid: this.id,\n\t\tcompletedAt: this.completedAt!,\n\t\ttasks: this.tasks.map(t => ({ id: t.id, name: t.name })),\n\t\tname: this.name,\n\t\trequest: this.request,\n\t\titems: [...this.testById.values()].map(TestResultItem.serialize),\n\t}));\n}\n\n/**\n * Test results hydrated from a previously-serialized test run.\n */\nexport class HydratedTestResult implements ITestResult {\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly counts = makeEmptyCounts();\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly id: string;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly completedAt: number;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly tasks: ITestRunTaskResults[];\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic get tests() {\n\t\treturn this.testById.values();\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly name: string;\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic readonly request: ResolvedTestRunRequest;\n\n\tprivate readonly testById = new Map<string, TestResultItem>();\n\n\tconstructor(\n\t\tprivate readonly serialized: ISerializedTestResults,\n\t\tprivate readonly persist = true,\n\t) {\n\t\tthis.id = serialized.id;\n\t\tthis.completedAt = serialized.completedAt;\n\t\tthis.tasks = serialized.tasks.map((task, i) => ({\n\t\t\tid: task.id,\n\t\t\tname: task.name,\n\t\t\trunning: false,\n\t\t\tcoverage: staticObservableValue(undefined),\n\t\t\toutput: emptyRawOutput,\n\t\t\totherMessages: []\n\t\t}));\n\t\tthis.name = serialized.name;\n\t\tthis.request = serialized.request;\n\n\t\tfor (const item of serialized.items) {\n\t\t\tconst de = TestResultItem.deserialize(item);\n\t\t\tthis.counts[de.ownComputedState]++;\n\t\t\tthis.testById.set(item.item.extId, de);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic getStateById(extTestId: string) {\n\t\treturn this.testById.get(extTestId);\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSON(): ISerializedTestResults | undefined {\n\t\treturn this.persist ? this.serialized : undefined;\n\t}\n\n\t/**\n\t * @inheritdoc\n\t */\n\tpublic toJSONWithMessages(): ISerializedTestResults | undefined {\n\t\treturn this.toJSON();\n\t}\n}\n"]}